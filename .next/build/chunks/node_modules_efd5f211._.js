module.exports = [
"[project]/node_modules/@alloc/quick-lru/index.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class QuickLRU {
    constructor(options = {}){
        if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        if (typeof options.maxAge === 'number' && options.maxAge === 0) {
            throw new TypeError('`maxAge` must be a number greater than 0');
        }
        this.maxSize = options.maxSize;
        this.maxAge = options.maxAge || Infinity;
        this.onEviction = options.onEviction;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
    }
    _emitEvictions(cache) {
        if (typeof this.onEviction !== 'function') {
            return;
        }
        for (const [key, item] of cache){
            this.onEviction(key, item.value);
        }
    }
    _deleteIfExpired(key, item) {
        if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {
            if (typeof this.onEviction === 'function') {
                this.onEviction(key, item.value);
            }
            return this.delete(key);
        }
        return false;
    }
    _getOrDeleteIfExpired(key, item) {
        const deleted = this._deleteIfExpired(key, item);
        if (deleted === false) {
            return item.value;
        }
    }
    _getItemValue(key, item) {
        return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
    }
    _peek(key, cache) {
        const item = cache.get(key);
        return this._getItemValue(key, item);
    }
    _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
            this._size = 0;
            this._emitEvictions(this.oldCache);
            this.oldCache = this.cache;
            this.cache = new Map();
        }
    }
    _moveToRecent(key, item) {
        this.oldCache.delete(key);
        this._set(key, item);
    }
    *_entriesAscending() {
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield item;
                }
            }
        }
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield item;
            }
        }
    }
    get(key) {
        if (this.cache.has(key)) {
            const item = this.cache.get(key);
            return this._getItemValue(key, item);
        }
        if (this.oldCache.has(key)) {
            const item = this.oldCache.get(key);
            if (this._deleteIfExpired(key, item) === false) {
                this._moveToRecent(key, item);
                return item.value;
            }
        }
    }
    set(key, value, { maxAge = this.maxAge === Infinity ? undefined : Date.now() + this.maxAge } = {}) {
        if (this.cache.has(key)) {
            this.cache.set(key, {
                value,
                maxAge
            });
        } else {
            this._set(key, {
                value,
                expiry: maxAge
            });
        }
    }
    has(key) {
        if (this.cache.has(key)) {
            return !this._deleteIfExpired(key, this.cache.get(key));
        }
        if (this.oldCache.has(key)) {
            return !this._deleteIfExpired(key, this.oldCache.get(key));
        }
        return false;
    }
    peek(key) {
        if (this.cache.has(key)) {
            return this._peek(key, this.cache);
        }
        if (this.oldCache.has(key)) {
            return this._peek(key, this.oldCache);
        }
    }
    delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
            this._size--;
        }
        return this.oldCache.delete(key) || deleted;
    }
    clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
    }
    resize(newSize) {
        if (!(newSize && newSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        const items = [
            ...this._entriesAscending()
        ];
        const removeCount = items.length - newSize;
        if (removeCount < 0) {
            this.cache = new Map(items);
            this.oldCache = new Map();
            this._size = items.length;
        } else {
            if (removeCount > 0) {
                this._emitEvictions(items.slice(0, removeCount));
            }
            this.oldCache = new Map(items.slice(removeCount));
            this.cache = new Map();
            this._size = 0;
        }
        this.maxSize = newSize;
    }
    *keys() {
        for (const [key] of this){
            yield key;
        }
    }
    *values() {
        for (const [, value] of this){
            yield value;
        }
    }
    *[Symbol.iterator]() {
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesDescending() {
        let items = [
            ...this.cache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        items = [
            ...this.oldCache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesAscending() {
        for (const [key, value] of this._entriesAscending()){
            yield [
                key,
                value.value
            ];
        }
    }
    get size() {
        if (!this._size) {
            return this.oldCache.size;
        }
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()){
            if (!this.cache.has(key)) {
                oldCacheSize++;
            }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
    }
}
module.exports = QuickLRU;
}),
"[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

var constants = __turbopack_context__.r("[externals]/constants [external] (constants, cjs)");
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!cwd) cwd = origCwd.call(process);
    return cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
    var chdir = process.chdir;
    process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
module.exports = patch;
function patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
    }
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
        patchLutimes(fs);
    }
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if (platform === "win32") {
        fs.rename = typeof fs.rename !== 'function' ? fs.rename : function(fs$rename) {
            function rename(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                    if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                        setTimeout(function() {
                            fs.stat(to, function(stater, st) {
                                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                else cb(er);
                            });
                        }, backoff);
                        if (backoff < 100) backoff += 10;
                        return;
                    }
                    if (cb) cb(er);
                });
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
            return rename;
        }(fs.rename);
    }
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== 'function' ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === 'function') {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true){
                try {
                    return fs$readSync.call(fs, fd, buffer, offset, length, position);
                } catch (er) {
                    if (er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        continue;
                    }
                    throw er;
                }
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) {
                    try {
                        fs.closeSync(fd);
                    } catch (er) {}
                } else {
                    fs.closeSync(fd);
                }
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}
}),
"[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
module.exports = legacy;
function legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    //TURBOPACK unreachable
    ;
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = 'r';
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 64 * 1024;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.end === undefined) {
                this.end = Infinity;
            } else if ('number' !== typeof this.end) {
                throw TypeError('end must be a Number');
            }
            if (this.start > this.end) {
                throw new Error('start must be <= end');
            }
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit('error', err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit('open', fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.start < 0) {
                throw new Error('start must be >= zero');
            }
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}
}),
"[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = clone;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function clone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Object) var copy = {
        __proto__: getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}
}),
"[project]/node_modules/graceful-fs/graceful-fs.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var polyfills = __turbopack_context__.r("[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)");
var legacy = __turbopack_context__.r("[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)");
var clone = __turbopack_context__.r("[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/* istanbul ignore next - node 0.x polyfill */ var gracefulQueue;
var previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
    gracefulQueue = Symbol.for('graceful-fs.queue');
    // This is used in testing by future versions
    previousSymbol = Symbol.for('graceful-fs.previous');
} else {
    gracefulQueue = '___graceful-fs.queue';
    previousSymbol = '___graceful-fs.previous';
}
function noop() {}
function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function() {
    var m = util.format.apply(util, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
};
// Once time initialization
if (!fs[gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var queue = /*TURBOPACK member replacement*/ __turbopack_context__.g[gracefulQueue] || [];
    publishQueue(fs, queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call(fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) {
                    resetQueue();
                }
                if (typeof cb === 'function') cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, previousSymbol, {
            value: fs$close
        });
        return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments);
            resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function() {
            debug(fs[gracefulQueue]);
            __turbopack_context__.r("[externals]/assert [external] (assert, cjs)").equal(fs[gracefulQueue].length, 0);
        });
    }
}
if (!/*TURBOPACK member replacement*/ __turbopack_context__.g[gracefulQueue]) {
    publishQueue(/*TURBOPACK member replacement*/ __turbopack_context__.g, fs[gracefulQueue]);
}
module.exports = patch(clone(fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
}
function patch(fs) {
    // Everything that references the open() function needs to be in here
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$readFile(path, options, cb);
        //TURBOPACK unreachable
        ;
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        //TURBOPACK unreachable
        ;
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        //TURBOPACK unreachable
        ;
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === 'function') {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        //TURBOPACK unreachable
        ;
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        //TURBOPACK unreachable
        ;
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === 'function') cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, 'ReadStream', {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, 'WriteStream', {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, 'FileReadStream', {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, 'FileWriteStream', {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === 'function') cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        //TURBOPACK unreachable
        ;
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    return fs;
}
function enqueue(elem) {
    debug('ENQUEUE', elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
}
// keep track of the timeout between retry() calls
var retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue() {
    var now = Date.now();
    for(var i = 0; i < fs[gracefulQueue].length; ++i){
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now; // startTime
            fs[gracefulQueue][i][4] = now; // lastTime
        }
    }
    // call retry to make sure we're actively processing the queue
    retry();
}
function retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0) return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug('TIMEOUT', fn.name, args);
        var cb = args.pop();
        if (typeof cb === 'function') cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            debug('RETRY', fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem);
        }
    }
    // schedule our next run if one isn't already scheduled
    if (retryTimer === undefined) {
        retryTimer = setTimeout(retry, 0);
    }
}
}),
"[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deprecateContext = util.deprecate(()=>{}, "Hook.context is deprecated and will be removed");
function CALL_DELEGATE(...args) {
    this.call = this._createCall("sync");
    return this.call(...args);
}
function CALL_ASYNC_DELEGATE(...args) {
    this.callAsync = this._createCall("async");
    return this.callAsync(...args);
}
function PROMISE_DELEGATE(...args) {
    this.promise = this._createCall("promise");
    return this.promise(...args);
}
class Hook {
    constructor(args = [], name = undefined){
        this._args = args;
        this.name = name;
        this.taps = [];
        this.interceptors = [];
        this._call = CALL_DELEGATE;
        this.call = CALL_DELEGATE;
        this._callAsync = CALL_ASYNC_DELEGATE;
        this.callAsync = CALL_ASYNC_DELEGATE;
        this._promise = PROMISE_DELEGATE;
        this.promise = PROMISE_DELEGATE;
        this._x = undefined;
        // eslint-disable-next-line no-self-assign
        this.compile = this.compile;
        // eslint-disable-next-line no-self-assign
        this.tap = this.tap;
        // eslint-disable-next-line no-self-assign
        this.tapAsync = this.tapAsync;
        // eslint-disable-next-line no-self-assign
        this.tapPromise = this.tapPromise;
    }
    compile(_options) {
        throw new Error("Abstract: should be overridden");
    }
    _createCall(type) {
        return this.compile({
            taps: this.taps,
            interceptors: this.interceptors,
            args: this._args,
            type
        });
    }
    _tap(type, options, fn) {
        if (typeof options === "string") {
            options = {
                name: options.trim()
            };
        } else if (typeof options !== "object" || options === null) {
            throw new Error("Invalid tap options");
        }
        if (typeof options.name !== "string" || options.name === "") {
            throw new Error("Missing name for tap");
        }
        if (typeof options.context !== "undefined") {
            deprecateContext();
        }
        options = Object.assign({
            type,
            fn
        }, options);
        options = this._runRegisterInterceptors(options);
        this._insert(options);
    }
    tap(options, fn) {
        this._tap("sync", options, fn);
    }
    tapAsync(options, fn) {
        this._tap("async", options, fn);
    }
    tapPromise(options, fn) {
        this._tap("promise", options, fn);
    }
    _runRegisterInterceptors(options) {
        for (const interceptor of this.interceptors){
            if (interceptor.register) {
                const newOptions = interceptor.register(options);
                if (newOptions !== undefined) {
                    options = newOptions;
                }
            }
        }
        return options;
    }
    withOptions(options) {
        const mergeOptions = (opt)=>Object.assign({}, options, typeof opt === "string" ? {
                name: opt
            } : opt);
        return {
            name: this.name,
            tap: (opt, fn)=>this.tap(mergeOptions(opt), fn),
            tapAsync: (opt, fn)=>this.tapAsync(mergeOptions(opt), fn),
            tapPromise: (opt, fn)=>this.tapPromise(mergeOptions(opt), fn),
            intercept: (interceptor)=>this.intercept(interceptor),
            isUsed: ()=>this.isUsed(),
            withOptions: (opt)=>this.withOptions(mergeOptions(opt))
        };
    }
    isUsed() {
        return this.taps.length > 0 || this.interceptors.length > 0;
    }
    intercept(interceptor) {
        this._resetCompilation();
        this.interceptors.push(Object.assign({}, interceptor));
        if (interceptor.register) {
            for(let i = 0; i < this.taps.length; i++){
                this.taps[i] = interceptor.register(this.taps[i]);
            }
        }
    }
    _resetCompilation() {
        this.call = this._call;
        this.callAsync = this._callAsync;
        this.promise = this._promise;
    }
    _insert(item) {
        this._resetCompilation();
        let before;
        if (typeof item.before === "string") {
            before = new Set([
                item.before
            ]);
        } else if (Array.isArray(item.before)) {
            before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === "number") {
            stage = item.stage;
        }
        let i = this.taps.length;
        while(i > 0){
            i--;
            const tap = this.taps[i];
            this.taps[i + 1] = tap;
            const xStage = tap.stage || 0;
            if (before) {
                if (before.has(tap.name)) {
                    before.delete(tap.name);
                    continue;
                }
                if (before.size > 0) {
                    continue;
                }
            }
            if (xStage > stage) {
                continue;
            }
            i++;
            break;
        }
        this.taps[i] = item;
    }
}
Object.setPrototypeOf(Hook.prototype, null);
module.exports = Hook;
}),
"[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ class HookCodeFactory {
    constructor(config){
        this.config = config;
        this.options = undefined;
        this._args = undefined;
    }
    create(options) {
        this.init(options);
        let fn;
        switch(this.options.type){
            case "sync":
                fn = new Function(this.args(), `"use strict";\n${this.header()}${this.contentWithInterceptors({
                    onError: (err)=>`throw ${err};\n`,
                    onResult: (result)=>`return ${result};\n`,
                    resultReturns: true,
                    onDone: ()=>"",
                    rethrowIfPossible: true
                })}`);
                break;
            case "async":
                fn = new Function(this.args({
                    after: "_callback"
                }), `"use strict";\n${this.header()}${this.contentWithInterceptors({
                    onError: (err)=>`_callback(${err});\n`,
                    onResult: (result)=>`_callback(null, ${result});\n`,
                    onDone: ()=>"_callback();\n"
                })}`);
                break;
            case "promise":
                {
                    let errorHelperUsed = false;
                    const content = this.contentWithInterceptors({
                        onError: (err)=>{
                            errorHelperUsed = true;
                            return `_error(${err});\n`;
                        },
                        onResult: (result)=>`_resolve(${result});\n`,
                        onDone: ()=>"_resolve();\n"
                    });
                    let code = "";
                    code += '"use strict";\n';
                    code += this.header();
                    code += "return new Promise((function(_resolve, _reject) {\n";
                    if (errorHelperUsed) {
                        code += "var _sync = true;\n";
                        code += "function _error(_err) {\n";
                        code += "if(_sync)\n";
                        code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
                        code += "else\n";
                        code += "_reject(_err);\n";
                        code += "};\n";
                    }
                    code += content;
                    if (errorHelperUsed) {
                        code += "_sync = false;\n";
                    }
                    code += "}));\n";
                    fn = new Function(this.args(), code);
                    break;
                }
        }
        this.deinit();
        return fn;
    }
    setup(instance, options) {
        instance._x = options.taps.map((t)=>t.fn);
    }
    /**
	 * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
	 */ init(options) {
        this.options = options;
        this._args = [
            ...options.args
        ];
    }
    deinit() {
        this.options = undefined;
        this._args = undefined;
    }
    contentWithInterceptors(options) {
        if (this.options.interceptors.length > 0) {
            const { onError, onResult, onDone } = options;
            let code = "";
            for(let i = 0; i < this.options.interceptors.length; i++){
                const interceptor = this.options.interceptors[i];
                if (interceptor.call) {
                    code += `${this.getInterceptor(i)}.call(${this.args({
                        before: interceptor.context ? "_context" : undefined
                    })});\n`;
                }
            }
            code += this.content(Object.assign(options, {
                onError: onError && ((err)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.error) {
                            code += `${this.getInterceptor(i)}.error(${err});\n`;
                        }
                    }
                    code += onError(err);
                    return code;
                }),
                onResult: onResult && ((result)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.result) {
                            code += `${this.getInterceptor(i)}.result(${result});\n`;
                        }
                    }
                    code += onResult(result);
                    return code;
                }),
                onDone: onDone && (()=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.done) {
                            code += `${this.getInterceptor(i)}.done();\n`;
                        }
                    }
                    code += onDone();
                    return code;
                })
            }));
            return code;
        }
        return this.content(options);
    }
    header() {
        let code = "";
        code += this.needContext() ? "var _context = {};\n" : "var _context;\n";
        code += "var _x = this._x;\n";
        if (this.options.interceptors.length > 0) {
            code += "var _taps = this.taps;\n";
            code += "var _interceptors = this.interceptors;\n";
        }
        return code;
    }
    needContext() {
        for (const tap of this.options.taps)if (tap.context) return true;
        return false;
    }
    callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = "";
        let hasTapCached = false;
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.tap) {
                if (!hasTapCached) {
                    code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`;
                    hasTapCached = true;
                }
                code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});\n`;
            }
        }
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
        const tap = this.options.taps[tapIndex];
        switch(tap.type){
            case "sync":
                if (!rethrowIfPossible) {
                    code += `var _hasError${tapIndex} = false;\n`;
                    code += "try {\n";
                }
                if (onResult) {
                    code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                } else {
                    code += `_fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                }
                if (!rethrowIfPossible) {
                    code += "} catch(_err) {\n";
                    code += `_hasError${tapIndex} = true;\n`;
                    code += onError("_err");
                    code += "}\n";
                    code += `if(!_hasError${tapIndex}) {\n`;
                }
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                if (!rethrowIfPossible) {
                    code += "}\n";
                }
                break;
            case "async":
                {
                    let cbCode = "";
                    cbCode += onResult ? `(function(_err${tapIndex}, _result${tapIndex}) {\n` : `(function(_err${tapIndex}) {\n`;
                    cbCode += `if(_err${tapIndex}) {\n`;
                    cbCode += onError(`_err${tapIndex}`);
                    cbCode += "} else {\n";
                    if (onResult) {
                        cbCode += onResult(`_result${tapIndex}`);
                    }
                    if (onDone) {
                        cbCode += onDone();
                    }
                    cbCode += "}\n";
                    cbCode += "})";
                    code += `_fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined,
                        after: cbCode
                    })});\n`;
                    break;
                }
            case "promise":
                code += `var _hasResult${tapIndex} = false;\n`;
                code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
                    before: tap.context ? "_context" : undefined
                })});\n`;
                code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`;
                code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`;
                code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`;
                code += `_hasResult${tapIndex} = true;\n`;
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                code += `}), function(_err${tapIndex}) {\n`;
                code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`;
                code += onError(`!_err${tapIndex} ? new Error('Tap function (tapPromise) rejects "' + _err${tapIndex} + '" value') : _err${tapIndex}`);
                code += "});\n";
                break;
        }
        return code;
    }
    callTapsSeries({ onError, onResult, resultReturns, onDone, doneReturns, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const firstAsync = this.options.taps.findIndex((t)=>t.type !== "sync");
        const somethingReturns = resultReturns || doneReturns;
        let code = "";
        let current = onDone;
        let unrollCounter = 0;
        for(let j = this.options.taps.length - 1; j >= 0; j--){
            const i = j;
            const unroll = current !== onDone && (this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
            if (unroll) {
                unrollCounter = 0;
                code += `function _next${i}() {\n`;
                code += current();
                code += "}\n";
                current = ()=>`${somethingReturns ? "return " : ""}_next${i}();\n`;
            }
            const done = current;
            const doneBreak = (skipDone)=>{
                if (skipDone) return "";
                return onDone();
            };
            const content = this.callTap(i, {
                onError: (error)=>onError(i, error, done, doneBreak),
                onResult: onResult && ((result)=>onResult(i, result, done, doneBreak)),
                onDone: !onResult && done,
                rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
            });
            current = ()=>content;
        }
        code += current();
        return code;
    }
    callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const syncOnly = this.options.taps.every((t)=>t.type === "sync");
        let code = "";
        if (!syncOnly) {
            code += "var _looper = (function() {\n";
            code += "var _loopAsync = false;\n";
        }
        code += "var _loop;\n";
        code += "do {\n";
        code += "_loop = false;\n";
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.loop) {
                code += `${this.getInterceptor(i)}.loop(${this.args({
                    before: interceptor.context ? "_context" : undefined
                })});\n`;
            }
        }
        code += this.callTapsSeries({
            onError,
            onResult: (i, result, next, doneBreak)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += "_loop = true;\n";
                if (!syncOnly) code += "if(_loopAsync) _looper();\n";
                code += doneBreak(true);
                code += "} else {\n";
                code += next();
                code += "}\n";
                return code;
            },
            onDone: onDone && (()=>{
                let code = "";
                code += "if(!_loop) {\n";
                code += onDone();
                code += "}\n";
                return code;
            }),
            rethrowIfPossible: rethrowIfPossible && syncOnly
        });
        code += "} while(_loop);\n";
        if (!syncOnly) {
            code += "_loopAsync = true;\n";
            code += "});\n";
            code += "_looper();\n";
        }
        return code;
    }
    callTapsParallel({ onError, onResult, onDone, rethrowIfPossible, onTap = (i, run)=>run() }) {
        if (this.options.taps.length <= 1) {
            return this.callTapsSeries({
                onError,
                onResult,
                onDone,
                rethrowIfPossible
            });
        }
        let code = "";
        code += "do {\n";
        code += `var _counter = ${this.options.taps.length};\n`;
        if (onDone) {
            code += "var _done = (function() {\n";
            code += onDone();
            code += "});\n";
        }
        for(let i = 0; i < this.options.taps.length; i++){
            const done = ()=>{
                if (onDone) return "if(--_counter === 0) _done();\n";
                return "--_counter;";
            };
            const doneBreak = (skipDone)=>{
                if (skipDone || !onDone) return "_counter = 0;\n";
                return "_counter = 0;\n_done();\n";
            };
            code += "if(_counter <= 0) break;\n";
            code += onTap(i, ()=>this.callTap(i, {
                    onError: (error)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onError(i, error, done, doneBreak);
                        code += "}\n";
                        return code;
                    },
                    onResult: onResult && ((result)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onResult(i, result, done, doneBreak);
                        code += "}\n";
                        return code;
                    }),
                    onDone: !onResult && (()=>done()),
                    rethrowIfPossible
                }), done, doneBreak);
        }
        code += "} while(false);\n";
        return code;
    }
    args({ before, after } = {}) {
        let allArgs = this._args;
        if (before) allArgs = [
            before,
            ...allArgs
        ];
        if (after) allArgs = [
            ...allArgs,
            after
        ];
        if (allArgs.length === 0) {
            return "";
        }
        return allArgs.join(", ");
    }
    getTapFn(idx) {
        return `_x[${idx}]`;
    }
    getTap(idx) {
        return `_taps[${idx}]`;
    }
    getInterceptor(idx) {
        return `_interceptors[${idx}]`;
    }
}
module.exports = HookCodeFactory;
}),
"[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone }) {
        let code = "";
        code += `var _results = new Array(${this.options.taps.length});\n`;
        code += "var _checkDone = function() {\n";
        code += "for(var i = 0; i < _results.length; i++) {\n";
        code += "var item = _results[i];\n";
        code += "if(item === undefined) return false;\n";
        code += "if(item.result !== undefined) {\n";
        code += onResult("item.result");
        code += "return true;\n";
        code += "}\n";
        code += "if(item.error) {\n";
        code += onError("item.error");
        code += "return true;\n";
        code += "}\n";
        code += "}\n";
        code += "return false;\n";
        code += "}\n";
        code += this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onResult: (i, result, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onTap: (i, run, done, _doneBreak)=>{
                let code = "";
                if (i > 0) {
                    code += `if(${i} >= _results.length) {\n`;
                    code += done();
                    code += "} else {\n";
                }
                code += run();
                if (i > 0) code += "}\n";
                return code;
            },
            onDone
        });
        return code;
    }
}
const factory = new AsyncParallelBailHookCodeFactory();
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function AsyncParallelBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelBailHook.prototype = null;
module.exports = AsyncParallelBailHook;
}),
"[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncParallelHookCodeFactory();
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function AsyncParallelHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelHook.prototype = null;
module.exports = AsyncParallelHook;
}),
"[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)}\n} else {\n${next()}}\n`,
            resultReturns,
            onDone
        });
    }
}
const factory = new AsyncSeriesBailHookCodeFactory();
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function AsyncSeriesBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesBailHook.prototype = null;
module.exports = AsyncSeriesBailHook;
}),
"[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesHookCodeFactory();
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function AsyncSeriesHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesHook.prototype = null;
module.exports = AsyncSeriesHook;
}),
"[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsLooping({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesLoopHookCodeFactory();
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function AsyncSeriesLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesLoopHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesLoopHook.prototype = null;
module.exports = AsyncSeriesLoopHook;
}),
"[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, _onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += "}\n";
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0])
        });
    }
}
const factory = new AsyncSeriesWaterfallHookCodeFactory();
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function AsyncSeriesWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) {
        throw new Error("Waterfall hooks must have at least one argument");
    }
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesWaterfallHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesWaterfallHook.prototype = null;
module.exports = AsyncSeriesWaterfallHook;
}),
"[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const defaultFactory = (key, hook)=>hook;
class HookMap {
    constructor(factory, name = undefined){
        this._map = new Map();
        this.name = name;
        this._factory = factory;
        this._interceptors = [];
    }
    get(key) {
        return this._map.get(key);
    }
    for(key) {
        const hook = this.get(key);
        if (hook !== undefined) {
            return hook;
        }
        let newHook = this._factory(key);
        const interceptors = this._interceptors;
        for(let i = 0; i < interceptors.length; i++){
            newHook = interceptors[i].factory(key, newHook);
        }
        this._map.set(key, newHook);
        return newHook;
    }
    intercept(interceptor) {
        this._interceptors.push(Object.assign({
            factory: defaultFactory
        }, interceptor));
    }
}
HookMap.prototype.tap = util.deprecate(function tap(key, options, fn) {
    return this.for(key).tap(options, fn);
}, "HookMap#tap(key,) is deprecated. Use HookMap#for(key).tap() instead.");
HookMap.prototype.tapAsync = util.deprecate(function tapAsync(key, options, fn) {
    return this.for(key).tapAsync(options, fn);
}, "HookMap#tapAsync(key,) is deprecated. Use HookMap#for(key).tapAsync() instead.");
HookMap.prototype.tapPromise = util.deprecate(function tapPromise(key, options, fn) {
    return this.for(key).tapPromise(options, fn);
}, "HookMap#tapPromise(key,) is deprecated. Use HookMap#for(key).tapPromise() instead.");
module.exports = HookMap;
}),
"[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ class MultiHook {
    constructor(hooks, name = undefined){
        this.hooks = hooks;
        this.name = name;
    }
    tap(options, fn) {
        for (const hook of this.hooks){
            hook.tap(options, fn);
        }
    }
    tapAsync(options, fn) {
        for (const hook of this.hooks){
            hook.tapAsync(options, fn);
        }
    }
    tapPromise(options, fn) {
        for (const hook of this.hooks){
            hook.tapPromise(options, fn);
        }
    }
    isUsed() {
        for (const hook of this.hooks){
            if (hook.isUsed()) return true;
        }
        return false;
    }
    intercept(interceptor) {
        for (const hook of this.hooks){
            hook.intercept(interceptor);
        }
    }
    withOptions(options) {
        return new MultiHook(this.hooks.map((hook)=>hook.withOptions(options)), this.name);
    }
}
module.exports = MultiHook;
}),
"[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
            resultReturns,
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncBailHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncBailHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncBailHook");
};
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function SyncBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncBailHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncBailHook.prototype = null;
module.exports = SyncBailHook;
}),
"[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncHook");
};
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function SyncHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncHook.prototype = null;
module.exports = SyncHook;
}),
"[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsLooping({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncLoopHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncLoopHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncLoopHook");
};
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function SyncLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncLoopHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncLoopHook.prototype = null;
module.exports = SyncLoopHook;
}),
"[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += "}\n";
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0]),
            doneReturns: resultReturns,
            rethrowIfPossible
        });
    }
}
const factory = new SyncWaterfallHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};
function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
}
function SyncWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) {
        throw new Error("Waterfall hooks must have at least one argument");
    }
    const hook = new Hook(args, name);
    hook.constructor = SyncWaterfallHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncWaterfallHook.prototype = null;
module.exports = SyncWaterfallHook;
}),
"[project]/node_modules/tapable/lib/index.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ module.exports.AsyncParallelBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)");
module.exports.AsyncParallelHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)");
module.exports.AsyncSeriesBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)");
module.exports.AsyncSeriesHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)");
module.exports.AsyncSeriesLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)");
module.exports.AsyncSeriesWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)");
module.exports.HookMap = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)");
module.exports.MultiHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)");
module.exports.SyncBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)");
module.exports.SyncHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)");
module.exports.SyncLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)");
module.exports.SyncWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)");
module.exports.__esModule = true;
}),
"[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/vlq.ts
__turbopack_context__.s([
    "decode",
    ()=>decode,
    "decodeGeneratedRanges",
    ()=>decodeGeneratedRanges,
    "decodeOriginalScopes",
    ()=>decodeOriginalScopes,
    "encode",
    ()=>encode,
    "encodeGeneratedRanges",
    ()=>encodeGeneratedRanges,
    "encodeOriginalScopes",
    ()=>encodeOriginalScopes
]);
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for(let i = 0; i < chars.length; i++){
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function decodeInteger(reader, relative) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    do {
        const c = reader.next();
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    }while (integer & 32)
    const shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) {
        value = -2147483648 | -value;
    }
    return relative + value;
}
function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
    do {
        let clamped = delta & 31;
        delta >>>= 5;
        if (delta > 0) clamped |= 32;
        builder.write(intToChar[clamped]);
    }while (delta > 0)
    return num;
}
function hasMoreVlq(reader, max) {
    if (reader.pos >= max) return false;
    return reader.peek() !== comma;
}
// src/strings.ts
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
    decode (buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
    }
} : {
    decode (buf) {
        let out = "";
        for(let i = 0; i < buf.length; i++){
            out += String.fromCharCode(buf[i]);
        }
        return out;
    }
};
var StringWriter = class {
    constructor(){
        this.pos = 0;
        this.out = "";
        this.buffer = new Uint8Array(bufLength);
    }
    write(v) {
        const { buffer } = this;
        buffer[this.pos++] = v;
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    flush() {
        const { buffer, out, pos } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
};
var StringReader = class {
    constructor(buffer){
        this.pos = 0;
        this.buffer = buffer;
    }
    next() {
        return this.buffer.charCodeAt(this.pos++);
    }
    peek() {
        return this.buffer.charCodeAt(this.pos);
    }
    indexOf(char) {
        const { buffer, pos } = this;
        const idx = buffer.indexOf(char, pos);
        return idx === -1 ? buffer.length : idx;
    }
};
// src/scopes.ts
var EMPTY = [];
function decodeOriginalScopes(input) {
    const { length } = input;
    const reader = new StringReader(input);
    const scopes = [];
    const stack = [];
    let line = 0;
    for(; reader.pos < length; reader.pos++){
        line = decodeInteger(reader, line);
        const column = decodeInteger(reader, 0);
        if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
        }
        const kind = decodeInteger(reader, 0);
        const fields = decodeInteger(reader, 0);
        const hasName = fields & 1;
        const scope = hasName ? [
            line,
            column,
            0,
            0,
            kind,
            decodeInteger(reader, 0)
        ] : [
            line,
            column,
            0,
            0,
            kind
        ];
        let vars = EMPTY;
        if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
                const varsIndex = decodeInteger(reader, 0);
                vars.push(varsIndex);
            }while (hasMoreVlq(reader, length))
        }
        scope.vars = vars;
        scopes.push(scope);
        stack.push(scope);
    }
    return scopes;
}
function encodeOriginalScopes(scopes) {
    const writer = new StringWriter();
    for(let i = 0; i < scopes.length;){
        i = _encodeOriginalScopes(scopes, i, writer, [
            0
        ]);
    }
    return writer.flush();
}
function _encodeOriginalScopes(scopes, index, writer, state) {
    const scope = scopes[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
    if (index > 0) writer.write(comma);
    state[0] = encodeInteger(writer, startLine, state[0]);
    encodeInteger(writer, startColumn, 0);
    encodeInteger(writer, kind, 0);
    const fields = scope.length === 6 ? 1 : 0;
    encodeInteger(writer, fields, 0);
    if (scope.length === 6) encodeInteger(writer, scope[5], 0);
    for (const v of vars){
        encodeInteger(writer, v, 0);
    }
    for(index++; index < scopes.length;){
        const next = scopes[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) {
            break;
        }
        index = _encodeOriginalScopes(scopes, index, writer, state);
    }
    writer.write(comma);
    state[0] = encodeInteger(writer, endLine, state[0]);
    encodeInteger(writer, endColumn, 0);
    return index;
}
function decodeGeneratedRanges(input) {
    const { length } = input;
    const reader = new StringReader(input);
    const ranges = [];
    const stack = [];
    let genLine = 0;
    let definitionSourcesIndex = 0;
    let definitionScopeIndex = 0;
    let callsiteSourcesIndex = 0;
    let callsiteLine = 0;
    let callsiteColumn = 0;
    let bindingLine = 0;
    let bindingColumn = 0;
    do {
        const semi = reader.indexOf(";");
        let genColumn = 0;
        for(; reader.pos < semi; reader.pos++){
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
                const last = stack.pop();
                last[2] = genLine;
                last[3] = genColumn;
                continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
                const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
                definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
                definitionSourcesIndex = defSourcesIndex;
                range = [
                    genLine,
                    genColumn,
                    0,
                    0,
                    defSourcesIndex,
                    definitionScopeIndex
                ];
            } else {
                range = [
                    genLine,
                    genColumn,
                    0,
                    0
                ];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
                const prevCsi = callsiteSourcesIndex;
                const prevLine = callsiteLine;
                callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
                const sameSource = prevCsi === callsiteSourcesIndex;
                callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
                callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
                callsite = [
                    callsiteSourcesIndex,
                    callsiteLine,
                    callsiteColumn
                ];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
                bindings = [];
                do {
                    bindingLine = genLine;
                    bindingColumn = genColumn;
                    const expressionsCount = decodeInteger(reader, 0);
                    let expressionRanges;
                    if (expressionsCount < -1) {
                        expressionRanges = [
                            [
                                decodeInteger(reader, 0)
                            ]
                        ];
                        for(let i = -1; i > expressionsCount; i--){
                            const prevBl = bindingLine;
                            bindingLine = decodeInteger(reader, bindingLine);
                            bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                            const expression = decodeInteger(reader, 0);
                            expressionRanges.push([
                                expression,
                                bindingLine,
                                bindingColumn
                            ]);
                        }
                    } else {
                        expressionRanges = [
                            [
                                expressionsCount
                            ]
                        ];
                    }
                    bindings.push(expressionRanges);
                }while (hasMoreVlq(reader, semi))
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
        }
        genLine++;
        reader.pos = semi + 1;
    }while (reader.pos < length)
    return ranges;
}
function encodeGeneratedRanges(ranges) {
    if (ranges.length === 0) return "";
    const writer = new StringWriter();
    for(let i = 0; i < ranges.length;){
        i = _encodeGeneratedRanges(ranges, i, writer, [
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]);
    }
    return writer.flush();
}
function _encodeGeneratedRanges(ranges, index, writer, state) {
    const range = ranges[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range;
    if (state[0] < startLine) {
        catchupLine(writer, state[0], startLine);
        state[0] = startLine;
        state[1] = 0;
    } else if (index > 0) {
        writer.write(comma);
    }
    state[1] = encodeInteger(writer, range[1], state[1]);
    const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
    encodeInteger(writer, fields, 0);
    if (range.length === 6) {
        const { 4: sourcesIndex, 5: scopesIndex } = range;
        if (sourcesIndex !== state[2]) {
            state[3] = 0;
        }
        state[2] = encodeInteger(writer, sourcesIndex, state[2]);
        state[3] = encodeInteger(writer, scopesIndex, state[3]);
    }
    if (callsite) {
        const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
        if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
        } else if (callLine !== state[5]) {
            state[6] = 0;
        }
        state[4] = encodeInteger(writer, sourcesIndex, state[4]);
        state[5] = encodeInteger(writer, callLine, state[5]);
        state[6] = encodeInteger(writer, callColumn, state[6]);
    }
    if (bindings) {
        for (const binding of bindings){
            if (binding.length > 1) encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for(let i = 1; i < binding.length; i++){
                const expRange = binding[i];
                bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
                bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
                encodeInteger(writer, expRange[0], 0);
            }
        }
    }
    for(index++; index < ranges.length;){
        const next = ranges[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) {
            break;
        }
        index = _encodeGeneratedRanges(ranges, index, writer, state);
    }
    if (state[0] < endLine) {
        catchupLine(writer, state[0], endLine);
        state[0] = endLine;
        state[1] = 0;
    } else {
        writer.write(comma);
    }
    state[1] = encodeInteger(writer, endColumn, state[1]);
    return index;
}
function catchupLine(writer, lastLine, line) {
    do {
        writer.write(semicolon);
    }while (++lastLine < line)
}
// src/sourcemap-codec.ts
function decode(mappings) {
    const { length } = mappings;
    const reader = new StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    do {
        const semi = reader.indexOf(";");
        const line = [];
        let sorted = true;
        let lastCol = 0;
        genColumn = 0;
        while(reader.pos < semi){
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
                sourcesIndex = decodeInteger(reader, sourcesIndex);
                sourceLine = decodeInteger(reader, sourceLine);
                sourceColumn = decodeInteger(reader, sourceColumn);
                if (hasMoreVlq(reader, semi)) {
                    namesIndex = decodeInteger(reader, namesIndex);
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                        namesIndex
                    ];
                } else {
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn
                    ];
                }
            } else {
                seg = [
                    genColumn
                ];
            }
            line.push(seg);
            reader.pos++;
        }
        if (!sorted) sort(line);
        decoded.push(line);
        reader.pos = semi + 1;
    }while (reader.pos <= length)
    return decoded;
}
function sort(line) {
    line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[0] - b[0];
}
function encode(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        if (i > 0) writer.write(semicolon);
        if (line.length === 0) continue;
        let genColumn = 0;
        for(let j = 0; j < line.length; j++){
            const segment = line[j];
            if (j > 0) writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1) continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4) continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    return writer.flush();
}
;
 //# sourceMappingURL=sourcemap-codec.mjs.map
}),
"[project]/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Matches the scheme of a URL, eg "http://"
__turbopack_context__.s([
    "default",
    ()=>resolve
]);
const schemeRegex = /^[\w+.-]+:\/\//;
/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */ const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */ const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}
function isAbsolutePath(input) {
    return input.startsWith('/');
}
function isFileUrl(input) {
    return input.startsWith('file:');
}
function isRelative(input) {
    return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}
function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: 7 /* Absolute */ 
    };
}
function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
        const url = parseAbsoluteUrl('http:' + input);
        url.scheme = '';
        url.type = 6 /* SchemeRelative */ ;
        return url;
    }
    if (isAbsolutePath(input)) {
        const url = parseAbsoluteUrl('http://foo.com' + input);
        url.scheme = '';
        url.host = '';
        url.type = 5 /* AbsolutePath */ ;
        return url;
    }
    if (isFileUrl(input)) return parseFileUrl(input);
    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    url.scheme = '';
    url.host = '';
    url.type = input ? input.startsWith('?') ? 3 /* Query */  : input.startsWith('#') ? 2 /* Hash */  : 4 /* RelativePath */  : 1 /* Empty */ ;
    return url;
}
function stripPathFilename(path) {
    // If a path ends with a parent directory "..", then it's a relative path with excess parent
    // paths. It's not a file, so we can't strip it.
    if (path.endsWith('/..')) return path;
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}
function mergePaths(url, base) {
    normalizePath(base, base.type);
    // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
    // path).
    if (url.path === '/') {
        url.path = base.path;
    } else {
        // Resolution happens relative to the base path's directory, not the file.
        url.path = stripPathFilename(base.path) + url.path;
    }
}
/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */ function normalizePath(url, type) {
    const rel = type <= 4 /* RelativePath */ ;
    const pieces = url.path.split('/');
    // We need to preserve the first piece always, so that we output a leading slash. The item at
    // pieces[0] is an empty string.
    let pointer = 1;
    // Positive is the number of real directories we've output, used for popping a parent directory.
    // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
    let positive = 0;
    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
    // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
    // real directory, we won't need to append, unless the other conditions happen again.
    let addTrailingSlash = false;
    for(let i = 1; i < pieces.length; i++){
        const piece = pieces[i];
        // An empty directory, could be a trailing slash, or just a double "//" in the path.
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        // If we encounter a real directory, then we don't need to append anymore.
        addTrailingSlash = false;
        // A current directory, which we can always drop.
        if (piece === '.') continue;
        // A parent directory, we need to see if there are any real directories we can pop. Else, we
        // have an excess of parents, and we'll need to keep the "..".
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            } else if (rel) {
                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
            }
            continue;
        }
        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
        // any popped or dropped directories.
        pieces[pointer++] = piece;
        positive++;
    }
    let path = '';
    for(let i = 1; i < pointer; i++){
        path += '/' + pieces[i];
    }
    if (!path || addTrailingSlash && !path.endsWith('/..')) {
        path += '/';
    }
    url.path = path;
}
/**
 * Attempts to resolve `input` URL/path relative to `base`.
 */ function resolve(input, base) {
    if (!input && !base) return '';
    const url = parseUrl(input);
    let inputType = url.type;
    if (base && inputType !== 7 /* Absolute */ ) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch(inputType){
            case 1 /* Empty */ :
                url.hash = baseUrl.hash;
            // fall through
            case 2 /* Hash */ :
                url.query = baseUrl.query;
            // fall through
            case 3 /* Query */ :
            case 4 /* RelativePath */ :
                mergePaths(url, baseUrl);
            // fall through
            case 5 /* AbsolutePath */ :
                // The host, user, and port are joined, you can't copy one without the others.
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
            // fall through
            case 6 /* SchemeRelative */ :
                // The input doesn't have a schema at least, so we need to copy at least that over.
                url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType) inputType = baseType;
    }
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    switch(inputType){
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2 /* Hash */ :
        case 3 /* Query */ :
            return queryHash;
        case 4 /* RelativePath */ :
            {
                // The first char is always a "/", and we need it to be relative.
                const path = url.path.slice(1);
                if (!path) return queryHash || '.';
                if (isRelative(base || input) && !isRelative(path)) {
                    // If base started with a leading ".", or there is no base and input started with a ".",
                    // then we need to ensure that the relative path starts with a ".". We don't know if
                    // relative starts with a "..", though, so check before prepending.
                    return './' + path + queryHash;
                }
                return path + queryHash;
            }
        case 5 /* AbsolutePath */ :
            return url.path + queryHash;
        default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}
;
 //# sourceMappingURL=resolve-uri.mjs.map
}),
"[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/trace-mapping.ts
__turbopack_context__.s([
    "AnyMap",
    ()=>FlattenMap,
    "FlattenMap",
    ()=>FlattenMap,
    "GREATEST_LOWER_BOUND",
    ()=>GREATEST_LOWER_BOUND,
    "LEAST_UPPER_BOUND",
    ()=>LEAST_UPPER_BOUND,
    "TraceMap",
    ()=>TraceMap,
    "allGeneratedPositionsFor",
    ()=>allGeneratedPositionsFor,
    "decodedMap",
    ()=>decodedMap,
    "decodedMappings",
    ()=>decodedMappings,
    "eachMapping",
    ()=>eachMapping,
    "encodedMap",
    ()=>encodedMap,
    "encodedMappings",
    ()=>encodedMappings,
    "generatedPositionFor",
    ()=>generatedPositionFor,
    "isIgnored",
    ()=>isIgnored,
    "originalPositionFor",
    ()=>originalPositionFor,
    "presortedDecodedMap",
    ()=>presortedDecodedMap,
    "sourceContentFor",
    ()=>sourceContentFor,
    "traceSegment",
    ()=>traceSegment
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)");
// src/resolve.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$resolve$2d$uri$2f$dist$2f$resolve$2d$uri$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs [postcss] (ecmascript)");
;
;
// src/strip-filename.ts
function stripFilename(path) {
    if (!path) return "";
    const index = path.lastIndexOf("/");
    return path.slice(0, index + 1);
}
// src/resolve.ts
function resolver(mapUrl, sourceRoot) {
    const from = stripFilename(mapUrl);
    const prefix = sourceRoot ? sourceRoot + "/" : "";
    return (source)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$resolve$2d$uri$2f$dist$2f$resolve$2d$uri$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"])(prefix + (source || ""), from);
}
// src/sourcemap-segment.ts
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var REV_GENERATED_LINE = 1;
var REV_GENERATED_COLUMN = 2;
// src/sort.ts
function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length) return mappings;
    if (!owned) mappings = mappings.slice();
    for(let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)){
        mappings[i] = sortSegments(mappings[i], owned);
    }
    return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
    for(let i = start; i < mappings.length; i++){
        if (!isSorted(mappings[i])) return i;
    }
    return mappings.length;
}
function isSorted(line) {
    for(let j = 1; j < line.length; j++){
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
        }
    }
    return true;
}
function sortSegments(line, owned) {
    if (!owned) line = line.slice();
    return line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[COLUMN] - b[COLUMN];
}
// src/by-source.ts
function buildBySources(decoded, memos) {
    const sources = memos.map(()=>[]);
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            if (seg.length === 1) continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const source = sources[sourceIndex2];
            const segs = source[sourceLine] || (source[sourceLine] = []);
            segs.push([
                sourceColumn,
                i,
                seg[COLUMN]
            ]);
        }
    }
    for(let i = 0; i < sources.length; i++){
        const source = sources[i];
        for(let j = 0; j < source.length; j++){
            const line = source[j];
            if (line) line.sort(sortComparator);
        }
    }
    return sources;
}
// src/binary-search.ts
var found = false;
function binarySearch(haystack, needle, low, high) {
    while(low <= high){
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
            found = true;
            return mid;
        }
        if (cmp < 0) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    found = false;
    return low - 1;
}
function upperBound(haystack, needle, index) {
    for(let i = index + 1; i < haystack.length; index = i++){
        if (haystack[i][COLUMN] !== needle) break;
    }
    return index;
}
function lowerBound(haystack, needle, index) {
    for(let i = index - 1; i >= 0; index = i--){
        if (haystack[i][COLUMN] !== needle) break;
    }
    return index;
}
function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
    };
}
function memoizedBinarySearch(haystack, needle, state, key) {
    const { lastKey, lastNeedle, lastIndex } = state;
    let low = 0;
    let high = haystack.length - 1;
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
        } else {
            high = lastIndex;
        }
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return state.lastIndex = binarySearch(haystack, needle, low, high);
}
// src/types.ts
function parse(map) {
    return typeof map === "string" ? JSON.parse(map) : map;
}
// src/flatten-map.ts
var FlattenMap = function(map, mapUrl) {
    const parsed = parse(map);
    if (!("sections" in parsed)) {
        return new TraceMap(parsed, mapUrl);
    }
    const mappings = [];
    const sources = [];
    const sourcesContent = [];
    const names = [];
    const ignoreList = [];
    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
    const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings,
        ignoreList
    };
    return presortedDecodedMap(joined);
};
function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const { sections } = input;
    for(let i = 0; i < sections.length; i++){
        const { map, offset } = sections[i];
        let sl = stopLine;
        let sc = stopColumn;
        if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
                sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
                sc = columnOffset + nextOffset.column;
            }
        }
        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
    }
}
function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const parsed = parse(input);
    if ("sections" in parsed) return recurse(...arguments);
    const map = new TraceMap(parsed, mapUrl);
    const sourcesOffset = sources.length;
    const namesOffset = names.length;
    const decoded = decodedMappings(map);
    const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
    append(sources, resolvedSources);
    append(names, map.names);
    if (contents) append(sourcesContent, contents);
    else for(let i = 0; i < resolvedSources.length; i++)sourcesContent.push(null);
    if (ignores) for(let i = 0; i < ignores.length; i++)ignoreList.push(ignores[i] + sourcesOffset);
    for(let i = 0; i < decoded.length; i++){
        const lineI = lineOffset + i;
        if (lineI > stopLine) return;
        const out = getLine(mappings, lineI);
        const cOffset = i === 0 ? columnOffset : 0;
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
                out.push([
                    column
                ]);
                continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [
                column,
                sourcesIndex,
                sourceLine,
                sourceColumn
            ] : [
                column,
                sourcesIndex,
                sourceLine,
                sourceColumn,
                namesOffset + seg[NAMES_INDEX]
            ]);
        }
    }
}
function append(arr, other) {
    for(let i = 0; i < other.length; i++)arr.push(other[i]);
}
function getLine(arr, index) {
    for(let i = arr.length; i <= index; i++)arr[i] = [];
    return arr[index];
}
// src/trace-mapping.ts
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
    constructor(map, mapUrl){
        const isString = typeof map === "string";
        if (!isString && map._decodedMemo) return map;
        const parsed = parse(map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
        const resolve = resolver(mapUrl, sourceRoot);
        this.resolvedSources = sources.map(resolve);
        const { mappings } = parsed;
        if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
        } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
        } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
        } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
        }
        this._decodedMemo = memoizedState();
        this._bySources = void 0;
        this._bySourceMemos = void 0;
    }
};
function cast(map) {
    return map;
}
function encodedMappings(map) {
    var _a, _b;
    return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["encode"])(cast(map)._decoded);
}
function decodedMappings(map) {
    var _a;
    return (_a = cast(map))._decoded || (_a._decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["decode"])(cast(map)._encoded));
}
function traceSegment(map, line, column) {
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return null;
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index === -1 ? null : segments[index];
}
function originalPositionFor(map, needle) {
    let { line, column, bias } = needle;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return OMapping(null, null, null, null);
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    if (index === -1) return OMapping(null, null, null, null);
    const segment = segments[index];
    if (segment.length === 1) return OMapping(null, null, null, null);
    const { names, resolvedSources } = map;
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function generatedPositionFor(map, needle) {
    const { source, line, column, bias } = needle;
    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
}
function allGeneratedPositionsFor(map, needle) {
    const { source, line, column, bias } = needle;
    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
}
function eachMapping(map, cb) {
    const decoded = decodedMappings(map);
    const { names, resolvedSources } = map;
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
            }
            if (seg.length === 5) name = names[seg[4]];
            cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name
            });
        }
    }
}
function sourceIndex(map, source) {
    const { sources, resolvedSources } = map;
    let index = sources.indexOf(source);
    if (index === -1) index = resolvedSources.indexOf(source);
    return index;
}
function sourceContentFor(map, source) {
    const { sourcesContent } = map;
    if (sourcesContent == null) return null;
    const index = sourceIndex(map, source);
    return index === -1 ? null : sourcesContent[index];
}
function isIgnored(map, source) {
    const { ignoreList } = map;
    if (ignoreList == null) return false;
    const index = sourceIndex(map, source);
    return index === -1 ? false : ignoreList.includes(index);
}
function presortedDecodedMap(map, mapUrl) {
    const tracer = new TraceMap(clone(map, []), mapUrl);
    cast(tracer)._decoded = map.mappings;
    return tracer;
}
function decodedMap(map) {
    return clone(map, decodedMappings(map));
}
function encodedMap(map) {
    return clone(map, encodedMappings(map));
}
function clone(map, mappings) {
    return {
        version: map.version,
        file: map.file,
        names: map.names,
        sourceRoot: map.sourceRoot,
        sources: map.sources,
        sourcesContent: map.sourcesContent,
        mappings,
        ignoreList: map.ignoreList || map.x_google_ignoreList
    };
}
function OMapping(source, line, column, name) {
    return {
        source,
        line,
        column,
        name
    };
}
function GMapping(line, column) {
    return {
        line,
        column
    };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
    let index = memoizedBinarySearch(segments, column, memo, line);
    if (found) {
        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
    } else if (bias === LEAST_UPPER_BOUND) index++;
    if (index === -1 || index === segments.length) return -1;
    return index;
}
function sliceGeneratedPositions(segments, memo, line, column, bias) {
    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
    if (!found && bias === LEAST_UPPER_BOUND) min++;
    if (min === -1 || min === segments.length) return [];
    const matchedColumn = found ? column : segments[min][COLUMN];
    if (!found) min = lowerBound(segments, matchedColumn, min);
    const max = upperBound(segments, matchedColumn, min);
    const result = [];
    for(; min <= max; min++){
        const segment = segments[min];
        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
    }
    return result;
}
function generatedPosition(map, source, line, column, bias, all) {
    var _a, _b;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    const { sources, resolvedSources } = map;
    let sourceIndex2 = sources.indexOf(source);
    if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);
    if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);
    const bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));
    const generated = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));
    const segments = generated[sourceIndex2][line];
    if (segments == null) return all ? [] : GMapping(null, null);
    const memo = bySourceMemos[sourceIndex2];
    if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
    const index = traceSegmentInternal(segments, memo, line, column, bias);
    if (index === -1) return GMapping(null, null);
    const segment = segments[index];
    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
}
;
 //# sourceMappingURL=trace-mapping.mjs.map
}),
"[project]/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/set-array.ts
__turbopack_context__.s([
    "GenMapping",
    ()=>GenMapping,
    "addMapping",
    ()=>addMapping,
    "addSegment",
    ()=>addSegment,
    "allMappings",
    ()=>allMappings,
    "fromMap",
    ()=>fromMap,
    "maybeAddMapping",
    ()=>maybeAddMapping,
    "maybeAddSegment",
    ()=>maybeAddSegment,
    "setIgnore",
    ()=>setIgnore,
    "setSourceContent",
    ()=>setSourceContent,
    "toDecodedMap",
    ()=>toDecodedMap,
    "toEncodedMap",
    ()=>toEncodedMap
]);
// src/gen-mapping.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs [postcss] (ecmascript)");
var SetArray = class {
    constructor(){
        this._indexes = {
            __proto__: null
        };
        this.array = [];
    }
};
function cast(set) {
    return set;
}
function get(setarr, key) {
    return cast(setarr)._indexes[key];
}
function put(setarr, key) {
    const index = get(setarr, key);
    if (index !== void 0) return index;
    const { array, _indexes: indexes } = cast(setarr);
    const length = array.push(key);
    return indexes[key] = length - 1;
}
function remove(setarr, key) {
    const index = get(setarr, key);
    if (index === void 0) return;
    const { array, _indexes: indexes } = cast(setarr);
    for(let i = index + 1; i < array.length; i++){
        const k = array[i];
        array[i - 1] = k;
        indexes[k]--;
    }
    indexes[key] = void 0;
    array.pop();
}
;
;
// src/sourcemap-segment.ts
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
// src/gen-mapping.ts
var NO_NAME = -1;
var GenMapping = class {
    constructor({ file, sourceRoot } = {}){
        this._names = new SetArray();
        this._sources = new SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new SetArray();
    }
};
function cast2(map) {
    return map;
}
function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
}
function addMapping(map, mapping) {
    return addMappingInternal(false, map, mapping);
}
var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{
    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
};
var maybeAddMapping = (map, mapping)=>{
    return addMappingInternal(true, map, mapping);
};
function setSourceContent(map, source, content) {
    const { _sources: sources, _sourcesContent: sourcesContent } = cast2(map);
    const index = put(sources, source);
    sourcesContent[index] = content;
}
function setIgnore(map, source, ignore = true) {
    const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast2(map);
    const index = put(sources, source);
    if (index === sourcesContent.length) sourcesContent[index] = null;
    if (ignore) put(ignoreList, index);
    else remove(ignoreList, index);
}
function toDecodedMap(map) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast2(map);
    removeEmptyFinalLines(mappings);
    return {
        version: 3,
        file: map.file || void 0,
        names: names.array,
        sourceRoot: map.sourceRoot || void 0,
        sources: sources.array,
        sourcesContent,
        mappings,
        // originalScopes,
        // generatedRanges,
        ignoreList: ignoreList.array
    };
}
function toEncodedMap(map) {
    const decoded = toDecodedMap(map);
    return Object.assign({}, decoded, {
        // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
        // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
        mappings: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["encode"])(decoded.mappings)
    });
}
function fromMap(input) {
    const map = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["TraceMap"](input);
    const gen = new GenMapping({
        file: map.file,
        sourceRoot: map.sourceRoot
    });
    putAll(cast2(gen)._names, map.names);
    putAll(cast2(gen)._sources, map.sources);
    cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(()=>null);
    cast2(gen)._mappings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["decodedMappings"])(map);
    if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);
    return gen;
}
function allMappings(map) {
    const out = [];
    const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
    for(let i = 0; i < mappings.length; i++){
        const line = mappings[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const generated = {
                line: i + 1,
                column: seg[COLUMN]
            };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX]];
                original = {
                    line: seg[SOURCE_LINE] + 1,
                    column: seg[SOURCE_COLUMN]
                };
                if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
            }
            out.push({
                generated,
                source,
                original,
                name
            });
        }
    }
    return out;
}
function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast2(map);
    const line = getIndex(mappings, genLine);
    const index = getColumnIndex(line, genColumn);
    if (!source) {
        if (skipable && skipSourceless(line, index)) return;
        return insert(line, index, [
            genColumn
        ]);
    }
    assert(sourceLine);
    assert(sourceColumn);
    const sourcesIndex = put(sources, source);
    const namesIndex = name ? put(names, name) : NO_NAME;
    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
        return;
    }
    return insert(line, index, name ? [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn,
        namesIndex
    ] : [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn
    ]);
}
function assert(_val) {}
function getIndex(arr, index) {
    for(let i = arr.length; i <= index; i++){
        arr[i] = [];
    }
    return arr[index];
}
function getColumnIndex(line, genColumn) {
    let index = line.length;
    for(let i = index - 1; i >= 0; index = i--){
        const current = line[i];
        if (genColumn >= current[COLUMN]) break;
    }
    return index;
}
function insert(array, index, value) {
    for(let i = array.length; i > index; i--){
        array[i] = array[i - 1];
    }
    array[index] = value;
}
function removeEmptyFinalLines(mappings) {
    const { length } = mappings;
    let len = length;
    for(let i = len - 1; i >= 0; len = i, i--){
        if (mappings[i].length > 0) break;
    }
    if (len < length) mappings.length = len;
}
function putAll(setarr, array) {
    for(let i = 0; i < array.length; i++)put(setarr, array[i]);
}
function skipSourceless(line, index) {
    if (index === 0) return true;
    const prev = line[index - 1];
    return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    if (index === 0) return false;
    const prev = line[index - 1];
    if (prev.length === 1) return false;
    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
}
function addMappingInternal(skipable, map, mapping) {
    const { generated, source, original, name, content } = mapping;
    if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    }
    assert(original);
    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
}
;
 //# sourceMappingURL=gen-mapping.mjs.map
}),
"[project]/node_modules/@jridgewell/remapping/dist/remapping.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/build-source-map-tree.ts
__turbopack_context__.s([
    "default",
    ()=>remapping
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs [postcss] (ecmascript)");
// src/source-map-tree.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs [postcss] (ecmascript)");
;
;
;
var SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null, false);
var EMPTY_SOURCES = [];
function SegmentObject(source, line, column, name, content, ignore) {
    return {
        source,
        line,
        column,
        name,
        content,
        ignore
    };
}
function Source(map, sources, source, content, ignore) {
    return {
        map,
        sources,
        source,
        content,
        ignore
    };
}
function MapSource(map, sources) {
    return Source(map, sources, "", null, false);
}
function OriginalSource(source, content, ignore) {
    return Source(null, EMPTY_SOURCES, source, content, ignore);
}
function traceMappings(tree) {
    const gen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["GenMapping"]({
        file: tree.map.file
    });
    const { sources: rootSources, map } = tree;
    const rootNames = map.names;
    const rootMappings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["decodedMappings"])(map);
    for(let i = 0; i < rootMappings.length; i++){
        const segments = rootMappings[i];
        for(let j = 0; j < segments.length; j++){
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
                const source2 = rootSources[segment[1]];
                traced = originalPositionFor(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
                if (traced == null) continue;
            }
            const { column, line, name, content, source, ignore } = traced;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["maybeAddSegment"])(gen, i, genCol, source, line, column, name);
            if (source && content != null) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["setSourceContent"])(gen, source, content);
            if (ignore) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["setIgnore"])(gen, source, true);
        }
    }
    return gen;
}
function originalPositionFor(source, line, column, name) {
    if (!source.map) {
        return SegmentObject(source.source, line, column, name, source.content, source.ignore);
    }
    const segment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["traceSegment"])(source.map, line, column);
    if (segment == null) return null;
    if (segment.length === 1) return SOURCELESS_MAPPING;
    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
}
// src/build-source-map-tree.ts
function asArray(value) {
    if (Array.isArray(value)) return value;
    return [
        value
    ];
}
function buildSourceMapTree(input, loader) {
    const maps = asArray(input).map((m)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["TraceMap"](m, ""));
    const map = maps.pop();
    for(let i = 0; i < maps.length; i++){
        if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
        }
    }
    let tree = build(map, loader, "", 0);
    for(let i = maps.length - 1; i >= 0; i--){
        tree = MapSource(maps[i], [
            tree
        ]);
    }
    return tree;
}
function build(map, loader, importer, importerDepth) {
    const { resolvedSources, sourcesContent, ignoreList } = map;
    const depth = importerDepth + 1;
    const children = resolvedSources.map((sourceFile, i)=>{
        const ctx = {
            importer,
            depth,
            source: sourceFile || "",
            content: void 0,
            ignore: void 0
        };
        const sourceMap = loader(ctx.source, ctx);
        const { source, content, ignore } = ctx;
        if (sourceMap) return build(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["TraceMap"](sourceMap, source), loader, source, depth);
        const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
        const ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i) : false;
        return OriginalSource(source, sourceContent, ignored);
    });
    return MapSource(map, children);
}
;
var SourceMap = class {
    constructor(map, options){
        const out = options.decodedMappings ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["toDecodedMap"])(map) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["toEncodedMap"])(map);
        this.version = out.version;
        this.file = out.file;
        this.mappings = out.mappings;
        this.names = out.names;
        this.ignoreList = out.ignoreList;
        this.sourceRoot = out.sourceRoot;
        this.sources = out.sources;
        if (!options.excludeContent) {
            this.sourcesContent = out.sourcesContent;
        }
    }
    toString() {
        return JSON.stringify(this);
    }
};
// src/remapping.ts
function remapping(input, loader, options) {
    const opts = typeof options === "object" ? options : {
        excludeContent: !!options,
        decodedMappings: false
    };
    const tree = buildSourceMapTree(input, loader);
    return new SourceMap(traceMappings(tree), opts);
}
;
 //# sourceMappingURL=remapping.mjs.map
}),
"[project]/node_modules/lightningcss-wasm/node_modules/napi-wasm/index.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

const NAPI_OK = 0;
const NAPI_INVALID_ARG = 1;
const NAPI_STRING_EXPECTED = 3;
const NAPI_NUMBER_EXPECTED = 6;
const NAPI_BOOLEAN_EXPECTED = 7;
const NAPI_GENERIC_FAILURE = 9;
const NAPI_PENDING_EXCEPTION = 10;
const NAPI_CANCELED = 11;
const NAPI_HANDLE_SCOPE_MISMATCH = 13;
const NAPI_BIGINT_EXPECTED = 17;
const NAPI_NO_EXTERNAL_BUFFERS_ALLOWED = 22;
// https://nodejs.org/api/n-api.html#napi_property_attributes
const NAPI_WRITABLE = 1 << 0;
const NAPI_ENUMERABLE = 1 << 1;
const NAPI_CONFIGURABLE = 1 << 2;
const NAPI_STATIC = 1 << 10;
// https://nodejs.org/api/n-api.html#napi_typedarray_type
const typedArrays = [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    BigInt64Array,
    BigUint64Array
];
const environments = [];
class Environment {
    scopes = [];
    referenceId = 1;
    references = new Map();
    deferred = [
        null
    ];
    wrappedObjects = new WeakMap();
    externalObjects = new WeakMap();
    buffers = new Map();
    instanceData = 0;
    pendingException = null;
    constructor(instance){
        this.id = environments.length;
        environments.push(this);
        this.instance = instance;
        this.table = instance.exports.__indirect_function_table;
        this.exports = {};
        this.pushScope();
        let values = this.scopes[this.scopes.length - 1];
        let exports1 = values.length;
        values.push(this.exports);
        try {
            if (this.instance.exports.napi_register_module_v1) {
                this.instance.exports.napi_register_module_v1(this.id, exports1);
            }
            if (this.instance.exports.napi_register_wasm_v1) {
                this.instance.exports.napi_register_wasm_v1(this.id, exports1);
            }
        } finally{
            this.popScope();
            if (this.pendingException) {
                let e = this.pendingException;
                this.pendingException = null;
                throw e;
            }
        }
    }
    destroy() {
        environments[this.id] = undefined;
    }
    getString(ptr, len = strlen(this.memory, ptr)) {
        return decoder.decode(this.memory.subarray(ptr, Math.max(0, ptr + len)));
    }
    pushScope() {
        let id = this.scopes.length;
        this.scopes.push(id ? [
            ...this.scopes[id - 1]
        ] : [
            undefined,
            null,
            globalThis,
            true,
            false
        ]);
        return id;
    }
    popScope() {
        this.scopes.pop();
        // Update any buffers with values which might have been modified in WASM copy.
        for (let [buffer, slice] of this.buffers){
            // Ignore if buffer or slice has been detached.
            if (buffer.byteLength && slice.byteLength) {
                buffer.set(slice);
            }
        }
        this.buffers.clear();
    }
    get(idx) {
        return this.scopes[this.scopes.length - 1][idx];
    }
    set(idx, value) {
        this.scopes[this.scopes.length - 1][idx] = value;
    }
    pushValue(value, scope = this.scopes.length - 1) {
        let values = this.scopes[scope];
        let id = values.length;
        values.push(value);
        return id;
    }
    createValue(value, result, scope) {
        if (typeof value === 'boolean') {
            this.setPointer(result, value ? 3 : 4);
            return NAPI_OK;
        } else if (typeof value === 'undefined') {
            this.setPointer(result, 0);
            return NAPI_OK;
        } else if (value === null) {
            this.setPointer(result, 1);
            return NAPI_OK;
        } else if (value === globalThis) {
            this.setPointer(result, 2);
            return NAPI_OK;
        }
        let id = this.pushValue(value, scope);
        this.setPointer(result, id);
        return NAPI_OK;
    }
    setPointer(ptr, value) {
        this.u32[ptr >> 2] = value;
        return NAPI_OK;
    }
    _u32 = new Uint32Array();
    get u32() {
        if (this._u32.byteLength === 0) {
            this._u32 = new Uint32Array(this.instance.exports.memory.buffer);
        }
        return this._u32;
    }
    _i32 = new Int32Array();
    get i32() {
        if (this._i32.byteLength === 0) {
            this._i32 = new Int32Array(this.instance.exports.memory.buffer);
        }
        return this._i32;
    }
    _u16 = new Uint16Array();
    get u16() {
        if (this._u16.byteLength === 0) {
            this._u16 = new Uint16Array(this.instance.exports.memory.buffer);
        }
        return this._u16;
    }
    _u64 = new BigUint64Array();
    get u64() {
        if (this._u64.byteLength === 0) {
            this._u64 = new BigUint64Array(this.instance.exports.memory.buffer);
        }
        return this._u64;
    }
    _i64 = new BigInt64Array();
    get i64() {
        if (this._i64.byteLength === 0) {
            this._i64 = new BigInt64Array(this.instance.exports.memory.buffer);
        }
        return this._i64;
    }
    _f64 = new Float64Array();
    get f64() {
        if (this._f64.byteLength === 0) {
            this._f64 = new Float64Array(this.instance.exports.memory.buffer);
        }
        return this._f64;
    }
    _buf = new Uint8Array();
    get memory() {
        if (this._buf.byteLength === 0) {
            this._buf = new Uint8Array(this.instance.exports.memory.buffer);
        }
        return this._buf;
    }
    getBufferInfo(buf1, ptr) {
        if (this.buffers.has(buf1)) {
            let b = this.buffers.get(buf1);
            this.setPointer(ptr, b.byteOffset);
            return b.byteLength;
        }
        if (buf1 instanceof ArrayBuffer) {
            let b = this.copyBuffer(new Uint8Array(buf1));
            this.setPointer(ptr, b.byteOffset);
            return b.byteLength;
        }
        // If this is a view into WASM memory, no copies needed.
        if (buf1.buffer === this.instance.exports.memory.buffer) {
            this.setPointer(ptr, buf1.byteOffset);
            return buf1.byteLength;
        }
        let b = this.copyBuffer(new Uint8Array(buf1.buffer, buf1.byteOffset, buf1.byteLength));
        this.setPointer(ptr, b.byteOffset);
        return b.byteLength;
    }
    copyBuffer(data) {
        let ptr = this.instance.exports.napi_wasm_malloc(data.byteLength);
        let mem = this.memory;
        mem.set(data, ptr);
        let buf1 = mem.subarray(ptr, ptr + data.byteLength);
        let finalize = (_env, data)=>{
            if (this.instance.exports.napi_wasm_free) {
                this.instance.exports.napi_wasm_free(data);
            }
        };
        finalizationRegistry.register(buf1, new FinalizeRecord(this.id, finalize, 0, ptr));
        this.buffers.set(data, buf1);
        return buf1;
    }
    createFunction(cb, data) {
        let env1 = this;
        let fn = env1.table.get(cb);
        let func = function(...args) {
            let scope = env1.pushScope();
            try {
                let values = env1.scopes[scope];
                let info = values.length;
                values.push({
                    thisArg: this,
                    args,
                    data,
                    newTarget: new.target
                });
                let res = fn(env1.id, info);
                return env1.get(res);
            } finally{
                env1.popScope();
                if (env1.pendingException) {
                    let e = env1.pendingException;
                    env1.pendingException = null;
                    throw e;
                }
            }
        };
        return func;
    }
    readPropertyDescriptor(ptr) {
        // https://nodejs.org/api/n-api.html#napi_property_descriptor
        let buf1 = this.u32;
        let utf8name = buf1[ptr++];
        let nameValue = buf1[ptr++];
        let method = buf1[ptr++];
        let getter = buf1[ptr++];
        let setter = buf1[ptr++];
        let val = buf1[ptr++];
        let attrs = buf1[ptr++];
        let data = buf1[ptr++];
        let name = utf8name ? this.getString(utf8name) : this.get(nameValue);
        let writable = Boolean(attrs & NAPI_WRITABLE);
        let enumerable = Boolean(attrs & NAPI_ENUMERABLE);
        let configurable = Boolean(attrs & NAPI_CONFIGURABLE);
        let isStatic = Boolean(attrs & NAPI_STATIC);
        let get = getter ? this.createFunction(getter, data) : undefined;
        let set = setter ? this.createFunction(setter, data) : undefined;
        let value = method ? this.createFunction(method, data) : val ? this.get(val) : undefined;
        let descriptor = {
            name,
            static: isStatic,
            configurable,
            enumerable
        };
        if (get || set) {
            descriptor.get = get;
            descriptor.set = set;
        } else if (value) {
            descriptor.writable = writable;
            descriptor.value = value;
        }
        return descriptor;
    }
}
const decoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
const latin1Decoder = new TextDecoder('latin1');
const utf16Decoder = new TextDecoder('utf-16');
const encoder = new TextEncoder();
class FinalizeRecord {
    constructor(env1, finalize, hint, data){
        this.env = env1;
        this.finalize = finalize;
        this.hint = hint;
        this.data = data;
    }
}
const finalizationRegistry = new FinalizationRegistry((buffer)=>{
    if (buffer.finalize) {
        buffer.finalize(buffer.env, buffer.data, buffer.hint);
    }
});
class ExternalValue {
}
const threadsafeFunctions = [];
class ThreadSafeFunction {
    constructor(env1, fn, nativeFn, context){
        this.env = env1;
        this.fn = fn;
        this.nativeFn = nativeFn;
        this.context = context;
        this.id = threadsafeFunctions.length;
        threadsafeFunctions.push(this);
    }
}
const asyncWork = [
    null
];
class AsyncWork {
    constructor(env1, execute, complete, data){
        this.env = env1;
        this.execute = execute;
        this.complete = complete;
        this.data = data;
        this.id = asyncWork.length;
        asyncWork.push(this);
    }
}
const napi = {
    napi_open_handle_scope (env_id, result) {
        let env1 = environments[env_id];
        let id = env1.pushScope();
        return env1.setPointer(result, id);
    },
    napi_close_handle_scope (env_id, scope) {
        let env1 = environments[env_id];
        if (scope !== env1.scopes.length - 1) {
            return NAPI_HANDLE_SCOPE_MISMATCH;
        }
        env1.popScope();
        return NAPI_OK;
    },
    napi_open_escapable_handle_scope (env_id, result) {
        let env1 = environments[env_id];
        let id = env1.pushScope();
        return env1.setPointer(result, id);
    },
    napi_close_escapable_handle_scope (env_id, scope) {
        let env1 = environments[env_id];
        if (scope !== env1.scopes.length - 1) {
            return NAPI_HANDLE_SCOPE_MISMATCH;
        }
        env1.popScope();
        return NAPI_OK;
    },
    napi_escape_handle (env_id, scope_id, escapee, result) {
        let env1 = environments[env_id];
        let value = env1.get(escapee);
        // Create a value in the outer scope.
        return env1.createValue(value, result, scope_id - 1);
    },
    napi_create_object (env_id, result) {
        let env1 = environments[env_id];
        return env1.createValue({}, result);
    },
    napi_set_property (env_id, object, key, value) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let name = env1.get(key);
        let val = env1.get(value);
        obj[name] = val;
        return NAPI_OK;
    },
    napi_get_property (env_id, object, key, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let name = env1.get(key);
        return env1.createValue(obj[name], result);
    },
    napi_delete_property (env_id, object, key, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let name = env1.get(key);
        let res = false;
        try {
            res = delete obj[name];
        } catch (err) {}
        if (result) {
            env1.memory[result] = res ? 1 : 0;
        }
        return NAPI_OK;
    },
    napi_has_property (env_id, object, key, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let name = env1.get(key);
        // return env.setPointer(result, name in obj ? 1 : 0);
        env1.memory[result] = name in obj ? 1 : 0;
        return NAPI_OK;
    },
    napi_has_own_property (env_id, object, key, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let name = env1.get(key);
        env1.memory[result] = obj.hasOwnProperty(name) ? 1 : 0;
        return NAPI_OK;
    },
    napi_set_named_property (env_id, object, utf8Name, value) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let val = env1.get(value);
        let name = env1.getString(utf8Name);
        obj[name] = val;
        return NAPI_OK;
    },
    napi_get_named_property (env_id, object, utf8Name, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let name = env1.getString(utf8Name);
        return env1.createValue(obj[name], result);
    },
    napi_has_named_property (env_id, object, utf8Name, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let name = env1.getString(utf8Name);
        env1.memory[result] = name in obj ? 1 : 0;
        return NAPI_OK;
    },
    napi_get_property_names (env_id, object, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let properties = Object.keys(obj);
        return env1.createValue(properties, result);
    },
    napi_get_all_property_names (env_id, object, key_mode, key_filter, key_conversion, result) {
        throw new Error('not implemented');
    },
    napi_define_properties (env_id, object, property_count, properties) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let ptr = properties >> 2;
        for(let i = 0; i < property_count; i++){
            let descriptor = env1.readPropertyDescriptor(ptr);
            Object.defineProperty(obj, descriptor.name, descriptor);
            ptr += 8;
        }
        return NAPI_OK;
    },
    napi_object_freeze (env_id, object) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        Object.freeze(obj);
        return NAPI_OK;
    },
    napi_object_seal (env_id, object) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        Object.seal(obj);
        return NAPI_OK;
    },
    napi_get_prototype (env_id, object, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        return env1.createValue(Object.getPrototypeOf(obj), result);
    },
    napi_define_class (env_id, utf8name, length, constructor, data, property_count, properties, result) {
        let env1 = environments[env_id];
        let func = env1.createFunction(constructor, data);
        Object.defineProperty(func, 'name', {
            value: env1.getString(utf8name, length),
            configurable: true
        });
        let ptr = properties >> 2;
        for(let i = 0; i < property_count; i++){
            let descriptor = env1.readPropertyDescriptor(ptr);
            if (descriptor.static) {
                Object.defineProperty(func, descriptor.name, descriptor);
            } else {
                Object.defineProperty(func.prototype, descriptor.name, descriptor);
            }
            ptr += 8;
        }
        return env1.createValue(func, result);
    },
    napi_create_reference (env_id, value, refcount, result) {
        let env1 = environments[env_id];
        let id = env1.referenceId++;
        env1.references.set(id, {
            value: env1.get(value),
            refcount
        });
        return env1.setPointer(result, id);
    },
    napi_delete_reference (env_id, ref) {
        let env1 = environments[env_id];
        env1.references.delete(ref);
        return NAPI_OK;
    },
    napi_get_reference_value (env_id, ref, result) {
        let env1 = environments[env_id];
        let reference = env1.references.get(ref);
        return env1.createValue(reference.value, result);
    },
    napi_reference_ref (env_id, ref, result) {
        let env1 = environments[env_id];
        let reference = env1.references.get(ref);
        reference.refcount++;
        return env1.setPointer(result, reference.refcount);
    },
    napi_reference_unref (env_id, ref, result) {
        let env1 = environments[env_id];
        let reference = env1.references.get(ref);
        if (reference.refcount === 0) {
            return NAPI_GENERIC_FAILURE;
        }
        reference.refcount--;
        return env1.setPointer(result, reference.refcount);
    },
    napi_add_env_cleanup_hook () {
        return NAPI_OK;
    },
    napi_remove_env_cleanup_hook () {
        return NAPI_OK;
    },
    napi_add_async_cleanup_hook () {
        return NAPI_OK;
    },
    napi_remove_async_cleanup_hook () {
        return NAPI_OK;
    },
    napi_set_instance_data (env_id, data, finalize_cb, finalize_hint) {
        let env1 = environments[env_id];
        env1.instanceData = data;
        return NAPI_OK;
    },
    napi_get_instance_data (env_id, data) {
        let env1 = environments[env_id];
        return env1.setPointer(data, env1.instanceData);
    },
    napi_get_boolean (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.setPointer(result, value ? 3 : 4);
    },
    napi_get_value_bool (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "boolean") {
            return NAPI_BOOLEAN_EXPECTED;
        }
        env1.memory[result] = val ? 1 : 0;
        return NAPI_OK;
    },
    napi_create_int32 (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(value, result);
    },
    napi_get_value_int32 (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "number") {
            return NAPI_NUMBER_EXPECTED;
        }
        env1.i32[result >> 2] = val;
        return NAPI_OK;
    },
    napi_create_uint32 (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(value, result);
    },
    napi_get_value_uint32 (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "number") {
            return NAPI_NUMBER_EXPECTED;
        }
        return env1.setPointer(result, val);
    },
    napi_create_int64 (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(Number(value), result);
    },
    napi_get_value_int64 (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "number") {
            return NAPI_NUMBER_EXPECTED;
        }
        env1.i64[result >> 3] = val;
        return NAPI_OK;
    },
    napi_create_double (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(value, result);
    },
    napi_get_value_double (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "number") {
            return NAPI_NUMBER_EXPECTED;
        }
        env1.f64[result >> 3] = val;
        return NAPI_OK;
    },
    napi_create_bigint_int64 (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(BigInt.asIntN(64, value), result);
    },
    napi_get_value_bigint_int64 (env_id, value, result, lossless) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "bigint") {
            return NAPI_BIGINT_EXPECTED;
        }
        env1.i64[result >> 3] = val;
        if (lossless) {
            env1.memory[lossless] = BigInt.asIntN(64, val) === val ? 1 : 0;
        }
        return NAPI_OK;
    },
    napi_create_bigint_uint64 (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(BigInt.asUintN(64, value), result);
    },
    napi_get_value_bigint_uint64 (env_id, value, result, lossless) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "bigint") {
            return NAPI_BIGINT_EXPECTED;
        }
        env1.u64[result >> 3] = val;
        if (lossless) {
            env1.memory[lossless] = BigInt.asUintN(64, val) === val ? 1 : 0;
        }
        return NAPI_OK;
    },
    napi_create_bigint_words (env_id, sign_bit, word_count, words, result) {
        let env1 = environments[env_id];
        let buf1 = env1.u64;
        let ptr = words >> 3;
        let res = 0n;
        let shift = 0n;
        for(let i = 0; i < word_count; i++){
            let word = buf1[ptr++];
            res += word << shift;
            shift += 64n;
        }
        res *= BigInt((-1) ** sign_bit);
        return env1.createValue(res, result);
    },
    napi_get_value_bigint_words (env_id, value, sign_bit, word_count, words) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "bigint") {
            return NAPI_BIGINT_EXPECTED;
        }
        let count = env1.u32[word_count >> 2];
        if (sign_bit) {
            env1.i32[sign_bit] = val < 0n ? 1 : 0;
        }
        let i = 0;
        if (words) {
            let mask = (1n << 64n) - 1n;
            let buf1 = env1.u64;
            let ptr = words >> 3;
            if (val < 0n) {
                val = -val;
            }
            for(; i < count && val !== 0n; i++){
                buf1[ptr++] = val & mask;
                val >>= 64n;
            }
        }
        while(val > 0n){
            i++;
            val >>= 64n;
        }
        return env1.setPointer(word_count, i);
    },
    napi_get_null (env_id, result) {
        let env1 = environments[env_id];
        return env1.setPointer(result, 1);
    },
    napi_create_array (env_id, result) {
        let env1 = environments[env_id];
        return env1.createValue([], result);
    },
    napi_create_array_with_length (env_id, length, result) {
        let env1 = environments[env_id];
        return env1.createValue(new Array(length), result);
    },
    napi_set_element (env_id, object, index, value) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let val = env1.get(value);
        obj[index] = val;
        return NAPI_OK;
    },
    napi_get_element (env_id, object, index, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let val = obj[index];
        return env1.createValue(val, result);
    },
    napi_has_element (env_id, object, index, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        env1.memory[result] = obj.hasOwnProperty(index) ? 1 : 0;
        return NAPI_OK;
    },
    napi_delete_element (env_id, object, index, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let res = false;
        try {
            res = delete obj[index];
        } catch (err) {}
        if (result) {
            env1.memory[result] = res ? 1 : 0;
        }
        return NAPI_OK;
    },
    napi_get_array_length (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        return env1.setPointer(result, val.length);
    },
    napi_get_undefined (env_id, result) {
        let env1 = environments[env_id];
        return env1.setPointer(result, 0);
    },
    napi_create_function (env_id, utf8name, length, cb, data, result) {
        let env1 = environments[env_id];
        let func = env1.createFunction(cb, data);
        Object.defineProperty(func, 'name', {
            value: env1.getString(utf8name, length),
            configurable: true
        });
        return env1.createValue(func, result);
    },
    napi_call_function (env_id, recv, func, argc, argv, result) {
        let env1 = environments[env_id];
        let thisArg = env1.get(recv);
        let fn = env1.get(func);
        let args = new Array(argc);
        let mem = env1.u32;
        for(let i = 0; i < argc; i++){
            args[i] = env1.get(mem[argv >> 2]);
            argv += 4;
        }
        try {
            let res = fn.apply(thisArg, args);
            return env1.createValue(res, result);
        } catch (err) {
            env1.pendingException = err;
            return NAPI_PENDING_EXCEPTION;
        }
    },
    napi_new_instance (env_id, cons, argc, argv, result) {
        let env1 = environments[env_id];
        let Class = env1.get(cons);
        let args = new Array(argc);
        let mem = env1.u32;
        for(let i = 0; i < argc; i++){
            args[i] = env1.get(mem[argv >> 2]);
            argv += 4;
        }
        try {
            let value = new Class(...args);
            return env1.createValue(value, result);
        } catch (err) {
            env1.pendingException = err;
            return NAPI_PENDING_EXCEPTION;
        }
    },
    napi_get_cb_info (env_id, cbinfo, argc, argv, thisArg, data) {
        let env1 = environments[env_id];
        let info = env1.get(cbinfo);
        env1.setPointer(argc, info.args.length);
        for(let i = 0; i < info.args.length; i++){
            env1.createValue(info.args[i], argv);
            argv += 4;
        }
        env1.createValue(info.thisArg, thisArg);
        env1.setPointer(data, info.data);
        return NAPI_OK;
    },
    napi_get_new_target (env_id, cbinfo, result) {
        let env1 = environments[env_id];
        let info = env1.get(cbinfo);
        return env1.createValue(info.newTarget, result);
    },
    napi_create_threadsafe_function (env_id, func, async_resource, async_resource_name, max_queue_size, initial_thread_count, thread_finalize_data, thread_finalize_cb, context, call_js_cb, result) {
        let env1 = environments[env_id];
        let fn = func ? env1.get(func) : undefined;
        let cb = call_js_cb ? env1.table.get(call_js_cb) : undefined;
        let f = new ThreadSafeFunction(env1, fn, cb, context);
        if (thread_finalize_cb) {
            let cb = env1.table.get(thread_finalize_cb);
            finalizationRegistry.register(f, new FinalizeRecord(env_id, cb, 0, f.id));
        }
        env1.setPointer(result, f.id);
        return NAPI_OK;
    },
    napi_ref_threadsafe_function () {
        return NAPI_OK;
    },
    napi_unref_threadsafe_function () {
        return NAPI_OK;
    },
    napi_acquire_threadsafe_function () {
        return NAPI_OK;
    },
    napi_release_threadsafe_function (func, mode) {
        threadsafeFunctions[func] = undefined;
        return NAPI_OK;
    },
    napi_call_threadsafe_function (func, data, is_blocking) {
        let f = threadsafeFunctions[func];
        f.env.pushScope();
        try {
            if (f.nativeFn) {
                let id = f.fn ? f.env.pushValue(f.fn) : 0;
                f.nativeFn(f.env.id, id, f.context, data);
            } else if (f.fn) {
                f.fn();
            }
        } finally{
            f.env.popScope();
        }
    },
    napi_get_threadsafe_function_context (func, result) {
        let f = threadsafeFunctions[func];
        f.env.setPointer(result, f.context);
        return NAPI_OK;
    },
    napi_create_async_work (env_id, async_resource, async_resource_name, execute, complete, data, result) {
        let env1 = environments[env_id];
        let executeFn = execute ? env1.table.get(execute) : undefined;
        let completeFn = complete ? env1.table.get(complete) : undefined;
        let w = new AsyncWork(env1, executeFn, completeFn, data);
        env1.setPointer(result, w.id);
        return NAPI_OK;
    },
    napi_delete_async_work (env1, work1) {
        asyncWork[work1] = undefined;
        return NAPI_OK;
    },
    napi_queue_async_work (env1, work1) {
        queueMicrotask(()=>{
            let w = asyncWork[work1];
            if (w) {
                w.execute(env1, w.data);
                w.complete(env1, NAPI_OK, w.data);
            }
        });
        return NAPI_OK;
    },
    napi_cancel_async_work () {
        let w = asyncWork[work];
        w.complete(env, NAPI_CANCELED, w.data);
        asyncWork[work] = undefined;
        return NAPI_OK;
    },
    napi_throw (env_id, error) {
        let env1 = environments[env_id];
        env1.pendingException = env1.get(error);
        return NAPI_OK;
    },
    napi_throw_error (env_id, code, msg) {
        let env1 = environments[env_id];
        let err = new Error(env1.getString(msg));
        err.code = code;
        env1.pendingException = err;
        return NAPI_OK;
    },
    napi_throw_type_error (env_id, code, msg) {
        let env1 = environments[env_id];
        let err = new TypeError(env1.getString(msg));
        err.code = code;
        env1.pendingException = err;
        return NAPI_OK;
    },
    napi_throw_range_error (env_id, code, msg) {
        let env1 = environments[env_id];
        let err = new RangeError(env1.getString(msg));
        err.code = code;
        env1.pendingException = err;
        return NAPI_OK;
    },
    napi_create_error (env_id, code, msg, result) {
        let env1 = environments[env_id];
        let err = new Error(env1.get(msg));
        err.code = env1.get(code);
        return env1.createValue(err, result);
    },
    napi_create_type_error (env_id, code, msg, result) {
        let env1 = environments[env_id];
        let err = new TypeError(env1.get(msg));
        err.code = env1.get(code);
        return env1.createValue(err, result);
    },
    napi_create_range_error (env_id, code, msg, result) {
        let env1 = environments[env_id];
        let err = new RangeError(env1.get(msg));
        err.code = env1.get(code);
        return env1.createValue(err, result);
    },
    napi_get_and_clear_last_exception (env_id, result) {
        let env1 = environments[env_id];
        let e = env1.pendingException;
        env1.pendingException = null;
        return env1.createValue(e, result);
    },
    napi_is_exception_pending (env_id, result) {
        let env1 = environments[env_id];
        env1.memory[result] = env1.pendingException ? 1 : 0;
        return NAPI_OK;
    },
    napi_fatal_exception (env_id, err) {
        throw new Error('not implemented');
    },
    napi_fatal_error (location, location_len, message, message_len) {
        throw new Error('not implemented');
    },
    napi_get_global (env_id, result) {
        let env1 = environments[env_id];
        return env1.setPointer(result, 2);
    },
    napi_create_buffer (env_id, length, data, result) {
        let env1 = environments[env_id];
        let ptr = env1.instance.exports.napi_wasm_malloc(length);
        if (data) {
            env1.setPointer(data, ptr);
        }
        // Return a view into WASM memory.
        let buf1 = typeof globalThis.Buffer !== 'undefined' ? globalThis.Buffer.from(env1.memory.buffer, ptr, length) : env1.memory.subarray(ptr, ptr + length);
        let finalize = (_env, data)=>{
            if (env1.instance.exports.napi_wasm_free) {
                env1.instance.exports.napi_wasm_free(data);
            }
        };
        finalizationRegistry.register(buf1, new FinalizeRecord(env_id, finalize, 0, ptr));
        return env1.createValue(buf1, result);
    },
    napi_create_buffer_copy (env_id, length, data, result_data, result) {
        let env1 = environments[env_id];
        let ptr = env1.instance.exports.napi_wasm_malloc(length);
        env1.memory.set(env1.memory.subarray(data, data + length), ptr);
        if (result_data) {
            env1.setPointer(result_data, ptr);
        }
        // Return a view into WASM memory.
        let res = typeof globalThis.Buffer !== 'undefined' ? globalThis.Buffer.from(env1.memory.buffer, ptr, length) : env1.memory.subarray(ptr, ptr + length);
        let finalize = (_env, data)=>{
            if (env1.instance.exports.napi_wasm_free) {
                env1.instance.exports.napi_wasm_free(data);
            }
        };
        finalizationRegistry.register(buf, new FinalizeRecord(env_id, finalize, 0, ptr));
        return env1.createValue(res, result);
    },
    napi_create_external_buffer (env_id, length, data, finalize_cb, finalize_hint, result) {
        let env1 = environments[env_id];
        let buf1 = typeof globalThis.Buffer !== 'undefined' ? globalThis.Buffer.from(env1.memory.buffer, data, length) : env1.memory.subarray(data, data + length);
        if (finalize_cb) {
            let cb = env1.table.get(finalize_cb);
            finalizationRegistry.register(buf1, new FinalizeRecord(env_id, cb, finalize_hint, data));
        }
        return env1.createValue(buf1, result);
    },
    napi_get_buffer_info (env_id, value, data, length) {
        let env1 = environments[env_id];
        let buf1 = env1.get(value);
        let len = env1.getBufferInfo(buf1, data);
        return env1.setPointer(length, len);
    },
    napi_create_arraybuffer (env_id, length, data, result) {
        let env1 = environments[env_id];
        let buf1 = new ArrayBuffer(length);
        if (data) {
            // This copies the ArrayBuffer into the WASM memory.
            env1.getBufferInfo(buf1, data);
        }
        return env1.createValue(buf1, result);
    },
    napi_create_external_arraybuffer (env_id, data, length, finalize_cb, finalize_hint, result) {
        // There is no way to actually create an external ArrayBuffer without copying.
        // You can only create typed arrays as subarrays, not ArrayBuffer.
        return NAPI_NO_EXTERNAL_BUFFERS_ALLOWED;
    },
    napi_get_arraybuffer_info (env_id, value, data, length) {
        let env1 = environments[env_id];
        let len = env1.getBufferInfo(env1.get(value), data);
        return env1.setPointer(length, len);
    },
    napi_detach_arraybuffer (env_id, arraybuffer) {
        let env1 = environments[env_id];
        let buffer = env1.get(arraybuffer);
        if (typeof structuredClone === 'function') {
            structuredClone(buffer, {
                transfer: [
                    buffer
                ]
            });
        }
        return NAPI_OK;
    },
    napi_is_detached_arraybuffer (env_id, arraybuffer, result) {
        let env1 = environments[env_id];
        let buffer = env1.get(arraybuffer);
        env1.memory[result] = buffer.byteLength === 0 ? 1 : 0; // ??
        return NAPI_OK;
    },
    napi_create_typedarray (env_id, type, length, arraybuffer, offset, result) {
        let env1 = environments[env_id];
        let Class = typedArrays[type];
        let buffer = env1.get(arraybuffer);
        let buf1 = new Class(buffer, offset, length);
        return env1.createValue(buf1, result);
    },
    napi_create_dataview (env_id, byte_length, arraybuffer, byte_offset, result) {
        let env1 = environments[env_id];
        let buffer = env1.get(arraybuffer);
        let view = new DataView(buffer, byte_offset, byte_length);
        return env1.createValue(view, result);
    },
    napi_get_typedarray_info (env_id, typedarray, type, length, data, arraybuffer, byte_offset) {
        let env1 = environments[env_id];
        let val = env1.get(typedarray);
        env1.setPointer(type, typedArrays.findIndex((constructor)=>val instanceof constructor));
        env1.setPointer(length, val.length);
        env1.getBufferInfo(val, data);
        env1.createValue(val.buffer, arraybuffer);
        return env1.setPointer(byte_offset, val.byteOffset);
    },
    napi_get_dataview_info (env_id, dataview, byte_length, data, arraybuffer, byte_offset) {
        let env1 = environments[env_id];
        let val = env1.get(dataview);
        env1.setPointer(byte_length, val.byteLength);
        env1.getBufferInfo(val, data);
        env1.createValue(val.buffer, arraybuffer);
        return env1.setPointer(byte_offset, val.byteOffset);
    },
    napi_create_string_utf8 (env_id, str, length, result) {
        let env1 = environments[env_id];
        let s = decoder.decode(env1.memory.subarray(str, str + length));
        return env1.createValue(s, result);
    },
    napi_get_value_string_utf8 (env_id, value, buf1, bufsize, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "string") {
            return NAPI_STRING_EXPECTED;
        }
        if (buf1 == 0) {
            return env1.setPointer(result, utf8Length(val));
        }
        let res = encoder.encodeInto(val, env1.memory.subarray(buf1, buf1 + bufsize - 1));
        env1.memory[buf1 + res.written] = 0; // null terminate
        return env1.setPointer(result, res.written);
    },
    napi_create_string_latin1 (env_id, str, length, result) {
        let env1 = environments[env_id];
        let s = latin1Decoder.decode(env1.memory.subarray(str, str + length));
        return env1.createValue(s, result);
    },
    napi_get_value_string_latin1 (env_id, value, buf1, bufsize, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "string") {
            return NAPI_STRING_EXPECTED;
        }
        if (buf1 == 0) {
            return env1.setPointer(result, val.length);
        }
        let mem = env1.memory;
        let len = Math.min(val.length, bufsize - 1);
        for(let i = 0; i < len; i++){
            let code = val.charCodeAt(i);
            mem[buf1++] = code;
        }
        mem[buf1] = 0; // null terminate
        return env1.setPointer(result, len);
    },
    napi_create_string_utf16 (env_id, str, length, result) {
        let env1 = environments[env_id];
        let s = utf16Decoder.decode(env1.memory.subarray(str, str + length * 2));
        return env1.createValue(s, result);
    },
    napi_get_value_string_utf16 (env_id, value, buf1, bufsize, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        if (typeof val !== "string") {
            return NAPI_STRING_EXPECTED;
        }
        if (buf1 == 0) {
            return env1.setPointer(result, val.length);
        }
        let mem = env1.u16;
        let ptr = buf1 >> 1;
        let len = Math.min(val.length, bufsize - 1);
        for(let i = 0; i < len; i++){
            let code = val.charCodeAt(i);
            mem[ptr++] = code;
        }
        mem[ptr] = 0; // null terminate
        return env1.setPointer(result, len);
    },
    napi_create_date (env_id, time, result) {
        let env1 = environments[env_id];
        return env1.createValue(new Date(time), result);
    },
    napi_get_date_value (env_id, value, result) {
        let env1 = environments[env_id];
        let date = env1.get(value);
        env1.f64[result >> 3] = date.valueOf();
    },
    napi_create_symbol (env_id, description, result) {
        let env1 = environments[env_id];
        let desc = env1.get(description);
        return env1.createValue(Symbol(desc), result);
    },
    napi_coerce_to_bool (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(Boolean(env1.get(value)), result);
    },
    napi_coerce_to_number (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(Number(env1.get(value)), result);
    },
    napi_coerce_to_object (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(Object(env1.get(value)), result);
    },
    napi_coerce_to_string (env_id, value, result) {
        let env1 = environments[env_id];
        return env1.createValue(String(env1.get(value)), result);
    },
    napi_typeof (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        return env1.setPointer(result, (()=>{
            switch(typeof val){
                case 'undefined':
                    return 0;
                case 'boolean':
                    return 2;
                case 'number':
                    return 3;
                case 'string':
                    return 4;
                case 'symbol':
                    return 5;
                case 'object':
                    if (val === null) {
                        return 1;
                    } else if (val instanceof ExternalValue) {
                        return 8;
                    }
                    return 6;
                case 'function':
                    return 7;
                case 'bigint':
                    return 9;
            }
        })());
    },
    napi_instanceof (env_id, object, constructor, result) {
        let env1 = environments[env_id];
        let obj = env1.get(object);
        let cons = env1.get(constructor);
        env1.memory[result] = obj instanceof cons ? 1 : 0;
        return NAPI_OK;
    },
    napi_is_array (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        env1.memory[result] = Array.isArray(val) ? 1 : 0;
        return NAPI_OK;
    },
    napi_is_buffer (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        env1.memory[result] = (typeof globalThis.Buffer !== 'undefined' ? globalThis.Buffer.isBuffer(val) : val instanceof Uint8Array) ? 1 : 0;
        return NAPI_OK;
    },
    napi_is_date (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        env1.memory[result] = val instanceof Date ? 1 : 0;
        return NAPI_OK;
    },
    napi_is_error (env_id, value, result) {
        let env1 = environments[env_id];
        let err = env1.get(value);
        env1.memory[result] = err instanceof Error ? 1 : 0;
        return NAPI_OK;
    },
    napi_is_typedarray (env_id, value, result) {
        let env1 = environments[env_id];
        let buf1 = env1.get(value);
        env1.memory[result] = ArrayBuffer.isView(buf1) && !(buf1 instanceof DataView) ? 1 : 0;
        return NAPI_OK;
    },
    napi_is_dataview (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        env1.memory[result] = val instanceof DataView ? 1 : 0;
        return NAPI_OK;
    },
    napi_strict_equals (env_id, lhs, rhs, result) {
        let env1 = environments[env_id];
        env1.memory[result] = env1.get(lhs) === env1.get(rhs) ? 1 : 0;
        return NAPI_OK;
    },
    napi_wrap (env_id, js_object, native_object, finalize_cb, finalize_hint, result) {
        let env1 = environments[env_id];
        let obj = env1.get(js_object);
        env1.wrappedObjects.set(obj, native_object);
        if (finalize_cb) {
            let cb = env1.table.get(finalize_cb);
            finalizationRegistry.register(obj, new FinalizeRecord(env_id, cb, finalize_hint, native_object));
        }
        if (result) {
            return napi.napi_create_reference(env_id, js_object, 1, result);
        }
        return NAPI_OK;
    },
    napi_unwrap (env_id, js_object, result) {
        let env1 = environments[env_id];
        let obj = env1.get(js_object);
        let native_object = env1.wrappedObjects.get(obj);
        env1.setPointer(result, native_object);
        return NAPI_OK;
    },
    napi_remove_wrap (env_id, js_object, result) {
        let env1 = environments[env_id];
        let obj = env1.get(js_object);
        let native_object = env1.wrappedObjects.get(obj);
        finalizationRegistry.unregister(obj);
        env1.wrappedObjects.delete(obj);
        return env1.setPointer(result, native_object);
    },
    napi_type_tag_object (env_id, js_object, type_tag) {
        throw new Error('not implemented');
    },
    napi_check_object_type_tag (env_id, js_object, type_tag) {
        throw new Error('not implemented');
    },
    napi_add_finalizer (env_id, js_object, native_object, finalize_cb, finalize_hint, result) {
        let env1 = environments[env_id];
        let obj = env1.get(js_object);
        let cb = env1.table.get(finalize_cb);
        finalizationRegistry.register(obj, new FinalizeRecord(env_id, cb, finalize_hint, native_object));
        if (result) {
            return napi.napi_create_reference(env_id, js_object, 1, result);
        }
        return NAPI_OK;
    },
    napi_create_promise (env_id, deferred, promise) {
        let env1 = environments[env_id];
        let p = new Promise((resolve, reject)=>{
            let id = env1.deferred.length;
            env1.deferred.push({
                resolve,
                reject
            });
            env1.setPointer(deferred, id);
        });
        return env1.createValue(p, promise);
    },
    napi_resolve_deferred (env_id, deferred, resolution) {
        let env1 = environments[env_id];
        let { resolve } = env1.deferred[deferred];
        let value = env1.get(resolution);
        resolve(value);
        env1.deferred[deferred] = undefined;
        return NAPI_OK;
    },
    napi_reject_deferred (env_id, deferred, rejection) {
        let env1 = environments[env_id];
        let { reject } = env1.deferred[deferred];
        let value = env1.get(rejection);
        reject(value);
        env1.deferred[deferred] = undefined;
        return NAPI_OK;
    },
    napi_is_promise (env_id, value, result) {
        let env1 = environments[env_id];
        let val = env1.get(value);
        env1.memory[result] = val instanceof Promise ? 1 : 0;
        return NAPI_OK;
    },
    napi_run_script (env_id, script, result) {
        let env1 = environments[env_id];
        let source = env1.get(script);
        let res = (0, eval)(source);
        return env1.createValue(res, result);
    },
    napi_create_external (env_id, data, finalize_cb, finalize_hint, result) {
        let env1 = environments[env_id];
        let external = new ExternalValue;
        env1.externalObjects.set(external, data);
        if (finalize_cb) {
            let cb = env1.table.get(finalize_cb);
            finalizationRegistry.register(external, new FinalizeRecord(env_id, cb, finalize_hint, data));
        }
        return env1.createValue(external, result);
    },
    napi_get_value_external (env_id, value, result) {
        let env1 = environments[env_id];
        let external = env1.get(value);
        let val = env1.externalObjects.get(external);
        if (!val) {
            return NAPI_INVALID_ARG;
        }
        return env1.setPointer(result, val);
    },
    napi_adjust_external_memory () {
        return NAPI_OK;
    }
};
function strlen(buf1, ptr) {
    let len = 0;
    while(buf1[ptr] !== 0){
        len++;
        ptr++;
    }
    return len;
}
function utf8Length(string) {
    let len = 0;
    for(let i = 0; i < string.length; i++){
        let c = string.charCodeAt(i);
        if (c >= 0xd800 && c <= 0xdbff && i < string.length - 1) {
            let c2 = string.charCodeAt(++i);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = ((c & 0x3ff) << 10) + (c2 & 0x3ff) + 0x10000;
            } else {
                // unmatched surrogate.
                i--;
            }
        }
        if ((c & 0xffffff80) === 0) {
            len++;
        } else if ((c & 0xfffff800) === 0) {
            len += 2;
        } else if ((c & 0xffff0000) === 0) {
            len += 3;
        } else if ((c & 0xffe00000) === 0) {
            len += 4;
        }
    }
    return len;
}
exports.Environment = Environment;
exports.napi = napi;
}),
"[project]/node_modules/lightningcss-wasm/wasm-node.cjs [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// wasm/wasm-node.mjs
var wasm_node_exports = {};
__export(wasm_node_exports, {
    Features: ()=>Features,
    browserslistToTargets: ()=>browserslistToTargets,
    bundle: ()=>bundle,
    bundleAsync: ()=>bundleAsync,
    composeVisitors: ()=>composeVisitors,
    default: ()=>init,
    transform: ()=>transform,
    transformStyleAttribute: ()=>transformStyleAttribute
});
module.exports = __toCommonJS(wasm_node_exports);
// wasm/import.meta.url-polyfill.js
var import_meta_url = typeof document === "undefined" ? new ((()=>{
    const e = new Error("Cannot find module as expression is too dynamic");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})()).URL("file:" + ("TURBOPACK compile-time value", "/ROOT/node_modules/lightningcss-wasm/wasm-node.cjs")).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
// wasm/wasm-node.mjs
var import_napi_wasm = __turbopack_context__.r("[project]/node_modules/lightningcss-wasm/node_modules/napi-wasm/index.js [postcss] (ecmascript)");
// wasm/async.mjs
var cur_await_promise_sync;
function await_promise_sync(promise_addr, result_addr, error_addr) {
    cur_await_promise_sync(promise_addr, result_addr, error_addr);
}
var State = {
    None: 0,
    Unwinding: 1,
    Rewinding: 2
};
function createBundleAsync(env2) {
    let { instance: instance2, exports: exports2 } = env2;
    let { asyncify_get_state, asyncify_start_unwind, asyncify_stop_unwind, asyncify_start_rewind, asyncify_stop_rewind } = instance2.exports;
    let DATA_ADDR = instance2.exports.napi_wasm_malloc(8 + 4096);
    let DATA_START = DATA_ADDR + 8;
    let DATA_END = DATA_ADDR + 8 + 4096;
    new Int32Array(env2.memory.buffer, DATA_ADDR).set([
        DATA_START,
        DATA_END
    ]);
    function assertNoneState() {
        if (asyncify_get_state() !== State.None) {
            throw new Error(`Invalid async state ${asyncify_get_state()}, expected 0.`);
        }
    }
    let promise, result, error;
    cur_await_promise_sync = (promise_addr, result_addr, error_addr)=>{
        let state = asyncify_get_state();
        if (state === State.Rewinding) {
            asyncify_stop_rewind();
            if (result != null) {
                env2.createValue(result, result_addr);
            }
            if (error != null) {
                env2.createValue(error, error_addr);
            }
            promise = result = error = null;
            return;
        }
        assertNoneState();
        promise = env2.get(promise_addr);
        asyncify_start_unwind(DATA_ADDR);
    };
    return async function bundleAsync2(options) {
        assertNoneState();
        let res = exports2.bundle(options);
        while(asyncify_get_state() === State.Unwinding){
            asyncify_stop_unwind();
            try {
                result = await promise;
            } catch (err) {
                error = err;
            }
            assertNoneState();
            asyncify_start_rewind(DATA_ADDR);
            res = exports2.bundle(options);
        }
        assertNoneState();
        return res;
    };
}
// wasm/wasm-node.mjs
var import_fs = __toESM(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"), 1);
var import_node_crypto = __turbopack_context__.r("[externals]/node:crypto [external] (node:crypto, cjs)");
// wasm/browserslistToTargets.js
var BROWSER_MAPPING = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    op_mob: "opera",
    and_qq: null,
    and_uc: null,
    baidu: null,
    bb: null,
    kaios: null,
    op_mini: null
};
function browserslistToTargets(browserslist) {
    let targets = {};
    for (let browser of browserslist){
        let [name, v] = browser.split(" ");
        if (BROWSER_MAPPING[name] === null) {
            continue;
        }
        let version = parseVersion(v);
        if (version == null) {
            continue;
        }
        if (targets[name] == null || version < targets[name]) {
            targets[name] = version;
        }
    }
    return targets;
}
function parseVersion(version) {
    let [major, minor = 0, patch = 0] = version.split("-")[0].split(".").map((v)=>parseInt(v, 10));
    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
        return null;
    }
    return major << 16 | minor << 8 | patch;
}
// wasm/flags.js
var Features = {
    Nesting: 1,
    NotSelectorList: 2,
    DirSelector: 4,
    LangSelectorList: 8,
    IsSelector: 16,
    TextDecorationThicknessPercent: 32,
    MediaIntervalSyntax: 64,
    MediaRangeSyntax: 128,
    CustomMediaQueries: 256,
    ClampFunction: 512,
    ColorFunction: 1024,
    OklabColors: 2048,
    LabColors: 4096,
    P3Colors: 8192,
    HexAlphaColors: 16384,
    SpaceSeparatedColorNotation: 32768,
    FontFamilySystemUi: 65536,
    DoublePositionGradients: 131072,
    VendorPrefixes: 262144,
    LogicalProperties: 524288,
    LightDark: 1048576,
    Selectors: 31,
    MediaQueries: 448,
    Colors: 1113088
};
// wasm/composeVisitors.js
function composeVisitors(visitors) {
    if (visitors.length === 1) {
        return visitors[0];
    }
    let res = {};
    composeSimpleVisitors(res, visitors, "StyleSheet");
    composeSimpleVisitors(res, visitors, "StyleSheetExit");
    composeObjectVisitors(res, visitors, "Rule", ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, "RuleExit", ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, "Declaration", declarationVisitor, wrapCustomProperty);
    composeObjectVisitors(res, visitors, "DeclarationExit", declarationVisitor, wrapCustomProperty);
    composeSimpleVisitors(res, visitors, "Url");
    composeSimpleVisitors(res, visitors, "Color");
    composeSimpleVisitors(res, visitors, "Image");
    composeSimpleVisitors(res, visitors, "ImageExit");
    composeSimpleVisitors(res, visitors, "Length");
    composeSimpleVisitors(res, visitors, "Angle");
    composeSimpleVisitors(res, visitors, "Ratio");
    composeSimpleVisitors(res, visitors, "Resolution");
    composeSimpleVisitors(res, visitors, "Time");
    composeSimpleVisitors(res, visitors, "CustomIdent");
    composeSimpleVisitors(res, visitors, "DashedIdent");
    composeArrayFunctions(res, visitors, "MediaQuery");
    composeArrayFunctions(res, visitors, "MediaQueryExit");
    composeSimpleVisitors(res, visitors, "SupportsCondition");
    composeSimpleVisitors(res, visitors, "SupportsConditionExit");
    composeArrayFunctions(res, visitors, "Selector");
    composeTokenVisitors(res, visitors, "Token", "token", false);
    composeTokenVisitors(res, visitors, "Function", "function", false);
    composeTokenVisitors(res, visitors, "FunctionExit", "function", true);
    composeTokenVisitors(res, visitors, "Variable", "var", false);
    composeTokenVisitors(res, visitors, "VariableExit", "var", true);
    composeTokenVisitors(res, visitors, "EnvironmentVariable", "env", false);
    composeTokenVisitors(res, visitors, "EnvironmentVariableExit", "env", true);
    return res;
}
function wrapCustomAndUnknownAtRule(k, f) {
    if (k === "unknown") {
        return (value)=>f({
                type: "unknown",
                value
            });
    }
    if (k === "custom") {
        return (value)=>f({
                type: "custom",
                value
            });
    }
    return f;
}
function wrapCustomProperty(k, f) {
    return k === "custom" ? (value)=>f({
            property: "custom",
            value
        }) : f;
}
function ruleVisitor(f, item) {
    if (typeof f === "object") {
        if (item.type === "unknown") {
            let v = f.unknown;
            if (typeof v === "object") {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        if (item.type === "custom") {
            let v = f.custom;
            if (typeof v === "object") {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[item.type]?.(item);
    }
    return f?.(item);
}
function declarationVisitor(f, item) {
    if (typeof f === "object") {
        let name = item.property;
        if (item.property === "unparsed") {
            name = item.value.propertyId.property;
        } else if (item.property === "custom") {
            let v = f.custom;
            if (typeof v === "object") {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[name]?.(item);
    }
    return f?.(item);
}
function extractObjectsOrFunctions(visitors, key) {
    let values = [];
    let hasFunction = false;
    let allKeys = /* @__PURE__ */ new Set();
    for (let visitor of visitors){
        let v = visitor[key];
        if (v) {
            if (typeof v === "function") {
                hasFunction = true;
            } else {
                for(let key2 in v){
                    allKeys.add(key2);
                }
            }
            values.push(v);
        }
    }
    return [
        values,
        hasFunction,
        allKeys
    ];
}
function composeObjectVisitors(res, visitors, key, apply, wrapKey) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createArrayVisitor(visitors, (visitor, item)=>apply(visitor[key], item));
    if (hasFunction) {
        res[key] = f;
    } else {
        let v = {};
        for (let k of allKeys){
            v[k] = wrapKey(k, f);
        }
        res[key] = v;
    }
}
function composeTokenVisitors(res, visitors, key, type, isExit) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createTokenVisitor(visitors, type, isExit);
    if (hasFunction) {
        res[key] = f;
    } else {
        let v = {};
        for (let key2 of allKeys){
            v[key2] = f;
        }
        res[key] = v;
    }
}
function createTokenVisitor(visitors, type, isExit) {
    let v = createArrayVisitor(visitors, (visitor, item)=>{
        let f;
        switch(item.type){
            case "token":
                f = visitor.Token;
                if (typeof f === "object") {
                    f = f[item.value.type];
                }
                break;
            case "function":
                f = isExit ? visitor.FunctionExit : visitor.Function;
                if (typeof f === "object") {
                    f = f[item.value.name];
                }
                break;
            case "var":
                f = isExit ? visitor.VariableExit : visitor.Variable;
                break;
            case "env":
                f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;
                if (typeof f === "object") {
                    let name;
                    switch(item.value.name.type){
                        case "ua":
                        case "unknown":
                            name = item.value.name.value;
                            break;
                        case "custom":
                            name = item.value.name.ident;
                            break;
                    }
                    f = f[name];
                }
                break;
            case "color":
                f = visitor.Color;
                break;
            case "url":
                f = visitor.Url;
                break;
            case "length":
                f = visitor.Length;
                break;
            case "angle":
                f = visitor.Angle;
                break;
            case "time":
                f = visitor.Time;
                break;
            case "resolution":
                f = visitor.Resolution;
                break;
            case "dashed-ident":
                f = visitor.DashedIdent;
                break;
        }
        if (!f) {
            return;
        }
        let res = f(item.value);
        switch(item.type){
            case "color":
            case "url":
            case "length":
            case "angle":
            case "time":
            case "resolution":
            case "dashed-ident":
                if (Array.isArray(res)) {
                    res = res.map((value)=>({
                            type: item.type,
                            value
                        }));
                } else if (res) {
                    res = {
                        type: item.type,
                        value: res
                    };
                }
                break;
        }
        return res;
    });
    return (value)=>v({
            type,
            value
        });
}
function extractFunctions(visitors, key) {
    let functions = [];
    for (let visitor of visitors){
        let f = visitor[key];
        if (f) {
            functions.push(f);
        }
    }
    return functions;
}
function composeSimpleVisitors(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = (arg)=>{
        let mutated = false;
        for (let f of functions){
            let res2 = f(arg);
            if (res2) {
                arg = res2;
                mutated = true;
            }
        }
        return mutated ? arg : void 0;
    };
}
function composeArrayFunctions(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = createArrayVisitor(functions, (f, item)=>f(item));
}
function createArrayVisitor(visitors, apply) {
    let seen = new Bitset(visitors.length);
    return (arg)=>{
        let arr = [
            arg
        ];
        let mutated = false;
        seen.clear();
        for(let i = 0; i < arr.length; i++){
            for(let v = 0; v < visitors.length;){
                if (seen.get(v)) {
                    v++;
                    continue;
                }
                let item = arr[i];
                let visitor = visitors[v];
                let res = apply(visitor, item);
                if (Array.isArray(res)) {
                    if (res.length === 0) {
                        arr.splice(i, 1);
                    } else if (res.length === 1) {
                        arr[i] = res[0];
                    } else {
                        arr.splice(i, 1, ...res);
                    }
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else if (res) {
                    arr[i] = res;
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else {
                    v++;
                }
            }
        }
        if (!mutated) {
            return;
        }
        return arr.length === 1 ? arr[0] : arr;
    };
}
var Bitset = class {
    constructor(maxBits = 32){
        this.bits = 0;
        this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;
    }
    /** @param {number} bit */ get(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            return Boolean(this.more[i] & 1 << b);
        } else {
            return Boolean(this.bits & 1 << bit);
        }
    }
    /** @param {number} bit */ set(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            this.more[i] |= 1 << b;
        } else {
            this.bits |= 1 << bit;
        }
    }
    clear() {
        this.bits = 0;
        if (this.more) {
            this.more.fill(0);
        }
    }
};
// wasm/wasm-node.mjs
var wasmBytes = import_fs.default.readFileSync(new URL("lightningcss_node.wasm", import_meta_url));
var wasmModule = new WebAssembly.Module(wasmBytes);
var instance = new WebAssembly.Instance(wasmModule, {
    env: {
        ...import_napi_wasm.napi,
        await_promise_sync,
        __getrandom_v03_custom: (ptr, len)=>{
            let buf = env.memory.subarray(ptr, ptr + len);
            import_node_crypto.webcrypto.getRandomValues(buf);
        }
    }
});
instance.exports.register_module();
var env = new import_napi_wasm.Environment(instance);
var wasm = env.exports;
var bundleAsyncInternal = createBundleAsync(env);
async function init() {}
function transform(options) {
    return wasm.transform(options);
}
function transformStyleAttribute(options) {
    return wasm.transformStyleAttribute(options);
}
function bundle(options) {
    return wasm.bundle({
        ...options,
        resolver: {
            read: (filePath)=>import_fs.default.readFileSync(filePath, "utf8")
        }
    });
}
async function bundleAsync(options) {
    if (!options.resolver?.read) {
        options.resolver = {
            ...options.resolver,
            read: (filePath)=>import_fs.default.readFileSync(filePath, "utf8")
        };
    }
    return bundleAsyncInternal(options);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    Features,
    browserslistToTargets,
    bundle,
    bundleAsync,
    composeVisitors,
    transform,
    transformStyleAttribute
});
}),
"[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

const BROWSER_MAPPING = {
    and_chr: 'chrome',
    and_ff: 'firefox',
    ie_mob: 'ie',
    op_mob: 'opera',
    and_qq: null,
    and_uc: null,
    baidu: null,
    bb: null,
    kaios: null,
    op_mini: null
};
function browserslistToTargets(browserslist) {
    let targets = {};
    for (let browser of browserslist){
        let [name, v] = browser.split(' ');
        if (BROWSER_MAPPING[name] === null) {
            continue;
        }
        let version = parseVersion(v);
        if (version == null) {
            continue;
        }
        if (targets[name] == null || version < targets[name]) {
            targets[name] = version;
        }
    }
    return targets;
}
function parseVersion(version) {
    let [major, minor = 0, patch = 0] = version.split('-')[0].split('.').map((v)=>parseInt(v, 10));
    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
        return null;
    }
    return major << 16 | minor << 8 | patch;
}
module.exports = browserslistToTargets;
}),
"[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

// @ts-check
/** @typedef {import('./index').Visitor} Visitor */ /**
 * Composes multiple visitor objects into a single one.
 * @param {Visitor[]} visitors 
 * @return {Visitor}
 */ function composeVisitors(visitors) {
    if (visitors.length === 1) {
        return visitors[0];
    }
    /** @type Visitor */ let res = {};
    composeSimpleVisitors(res, visitors, 'StyleSheet');
    composeSimpleVisitors(res, visitors, 'StyleSheetExit');
    composeObjectVisitors(res, visitors, 'Rule', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'RuleExit', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'Declaration', declarationVisitor, wrapCustomProperty);
    composeObjectVisitors(res, visitors, 'DeclarationExit', declarationVisitor, wrapCustomProperty);
    composeSimpleVisitors(res, visitors, 'Url');
    composeSimpleVisitors(res, visitors, 'Color');
    composeSimpleVisitors(res, visitors, 'Image');
    composeSimpleVisitors(res, visitors, 'ImageExit');
    composeSimpleVisitors(res, visitors, 'Length');
    composeSimpleVisitors(res, visitors, 'Angle');
    composeSimpleVisitors(res, visitors, 'Ratio');
    composeSimpleVisitors(res, visitors, 'Resolution');
    composeSimpleVisitors(res, visitors, 'Time');
    composeSimpleVisitors(res, visitors, 'CustomIdent');
    composeSimpleVisitors(res, visitors, 'DashedIdent');
    composeArrayFunctions(res, visitors, 'MediaQuery');
    composeArrayFunctions(res, visitors, 'MediaQueryExit');
    composeSimpleVisitors(res, visitors, 'SupportsCondition');
    composeSimpleVisitors(res, visitors, 'SupportsConditionExit');
    composeArrayFunctions(res, visitors, 'Selector');
    composeTokenVisitors(res, visitors, 'Token', 'token', false);
    composeTokenVisitors(res, visitors, 'Function', 'function', false);
    composeTokenVisitors(res, visitors, 'FunctionExit', 'function', true);
    composeTokenVisitors(res, visitors, 'Variable', 'var', false);
    composeTokenVisitors(res, visitors, 'VariableExit', 'var', true);
    composeTokenVisitors(res, visitors, 'EnvironmentVariable', 'env', false);
    composeTokenVisitors(res, visitors, 'EnvironmentVariableExit', 'env', true);
    return res;
}
module.exports = composeVisitors;
function wrapCustomAndUnknownAtRule(k, f) {
    if (k === 'unknown') {
        return (value)=>f({
                type: 'unknown',
                value
            });
    }
    if (k === 'custom') {
        return (value)=>f({
                type: 'custom',
                value
            });
    }
    return f;
}
function wrapCustomProperty(k, f) {
    return k === 'custom' ? (value)=>f({
            property: 'custom',
            value
        }) : f;
}
/**
 * @param {import('./index').Visitor['Rule']} f 
 * @param {import('./ast').Rule} item 
 */ function ruleVisitor(f, item) {
    if (typeof f === 'object') {
        if (item.type === 'unknown') {
            let v = f.unknown;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        if (item.type === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[item.type]?.(item);
    }
    return f?.(item);
}
/**
 * @param {import('./index').Visitor['Declaration']} f 
 * @param {import('./ast').Declaration} item 
 */ function declarationVisitor(f, item) {
    if (typeof f === 'object') {
        /** @type {string} */ let name = item.property;
        if (item.property === 'unparsed') {
            name = item.value.propertyId.property;
        } else if (item.property === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[name]?.(item);
    }
    return f?.(item);
}
/**
 * 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @returns {[any[], boolean, Set<string>]}
 */ function extractObjectsOrFunctions(visitors, key) {
    let values = [];
    let hasFunction = false;
    let allKeys = new Set();
    for (let visitor of visitors){
        let v = visitor[key];
        if (v) {
            if (typeof v === 'function') {
                hasFunction = true;
            } else {
                for(let key in v){
                    allKeys.add(key);
                }
            }
            values.push(v);
        }
    }
    return [
        values,
        hasFunction,
        allKeys
    ];
}
/**
 * @template {keyof Visitor} K
 * @param {Visitor} res
 * @param {Visitor[]} visitors
 * @param {K} key
 * @param {(visitor: Visitor[K], item: any) => any | any[] | void} apply 
 * @param {(k: string, f: any) => any} wrapKey 
 */ function composeObjectVisitors(res, visitors, key, apply, wrapKey) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createArrayVisitor(visitors, (visitor, item)=>apply(visitor[key], item));
    if (hasFunction) {
        res[key] = f;
    } else {
        /** @type {any} */ let v = {};
        for (let k of allKeys){
            v[k] = wrapKey(k, f);
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @param {import('./ast').TokenOrValue['type']} type 
 * @param {boolean} isExit 
 */ function composeTokenVisitors(res, visitors, key, type, isExit) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createTokenVisitor(visitors, type, isExit);
    if (hasFunction) {
        res[key] = f;
    } else {
        let v = {};
        for (let key of allKeys){
            v[key] = f;
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor[]} visitors 
 * @param {import('./ast').TokenOrValue['type']} type 
 */ function createTokenVisitor(visitors, type, isExit) {
    let v = createArrayVisitor(visitors, (visitor, /** @type {import('./ast').TokenOrValue} */ item)=>{
        let f;
        switch(item.type){
            case 'token':
                f = visitor.Token;
                if (typeof f === 'object') {
                    f = f[item.value.type];
                }
                break;
            case 'function':
                f = isExit ? visitor.FunctionExit : visitor.Function;
                if (typeof f === 'object') {
                    f = f[item.value.name];
                }
                break;
            case 'var':
                f = isExit ? visitor.VariableExit : visitor.Variable;
                break;
            case 'env':
                f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;
                if (typeof f === 'object') {
                    let name;
                    switch(item.value.name.type){
                        case 'ua':
                        case 'unknown':
                            name = item.value.name.value;
                            break;
                        case 'custom':
                            name = item.value.name.ident;
                            break;
                    }
                    f = f[name];
                }
                break;
            case 'color':
                f = visitor.Color;
                break;
            case 'url':
                f = visitor.Url;
                break;
            case 'length':
                f = visitor.Length;
                break;
            case 'angle':
                f = visitor.Angle;
                break;
            case 'time':
                f = visitor.Time;
                break;
            case 'resolution':
                f = visitor.Resolution;
                break;
            case 'dashed-ident':
                f = visitor.DashedIdent;
                break;
        }
        if (!f) {
            return;
        }
        let res = f(item.value);
        switch(item.type){
            case 'color':
            case 'url':
            case 'length':
            case 'angle':
            case 'time':
            case 'resolution':
            case 'dashed-ident':
                if (Array.isArray(res)) {
                    res = res.map((value)=>({
                            type: item.type,
                            value
                        }));
                } else if (res) {
                    res = {
                        type: item.type,
                        value: res
                    };
                }
                break;
        }
        return res;
    });
    return (value)=>v({
            type,
            value
        });
}
/**
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function extractFunctions(visitors, key) {
    let functions = [];
    for (let visitor of visitors){
        let f = visitor[key];
        if (f) {
            functions.push(f);
        }
    }
    return functions;
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeSimpleVisitors(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = (arg)=>{
        let mutated = false;
        for (let f of functions){
            let res = f(arg);
            if (res) {
                arg = res;
                mutated = true;
            }
        }
        return mutated ? arg : undefined;
    };
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeArrayFunctions(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = createArrayVisitor(functions, (f, item)=>f(item));
}
/**
 * @template T
 * @template V
 * @param {T[]} visitors 
 * @param {(visitor: T, item: V) => V | V[] | void} apply 
 * @returns {(item: V) => V | V[] | void}
 */ function createArrayVisitor(visitors, apply) {
    let seen = new Bitset(visitors.length);
    return (arg)=>{
        let arr = [
            arg
        ];
        let mutated = false;
        seen.clear();
        for(let i = 0; i < arr.length; i++){
            // For each value, call all visitors. If a visitor returns a new value,
            // we start over, but skip the visitor that generated the value or saw
            // it before (to avoid cycles). This way, visitors can be composed in any order. 
            for(let v = 0; v < visitors.length;){
                if (seen.get(v)) {
                    v++;
                    continue;
                }
                let item = arr[i];
                let visitor = visitors[v];
                let res = apply(visitor, item);
                if (Array.isArray(res)) {
                    if (res.length === 0) {
                        arr.splice(i, 1);
                    } else if (res.length === 1) {
                        arr[i] = res[0];
                    } else {
                        arr.splice(i, 1, ...res);
                    }
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else if (res) {
                    arr[i] = res;
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else {
                    v++;
                }
            }
        }
        if (!mutated) {
            return;
        }
        return arr.length === 1 ? arr[0] : arr;
    };
}
class Bitset {
    constructor(maxBits = 32){
        this.bits = 0;
        this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;
    }
    /** @param {number} bit */ get(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            return Boolean(this.more[i] & 1 << b);
        } else {
            return Boolean(this.bits & 1 << bit);
        }
    }
    /** @param {number} bit */ set(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            this.more[i] |= 1 << b;
        } else {
            this.bits |= 1 << bit;
        }
    }
    clear() {
        this.bits = 0;
        if (this.more) {
            this.more.fill(0);
        }
    }
}
}),
"[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

// This file is autogenerated by build-prefixes.js. DO NOT EDIT!
exports.Features = {
    Nesting: 1,
    NotSelectorList: 2,
    DirSelector: 4,
    LangSelectorList: 8,
    IsSelector: 16,
    TextDecorationThicknessPercent: 32,
    MediaIntervalSyntax: 64,
    MediaRangeSyntax: 128,
    CustomMediaQueries: 256,
    ClampFunction: 512,
    ColorFunction: 1024,
    OklabColors: 2048,
    LabColors: 4096,
    P3Colors: 8192,
    HexAlphaColors: 16384,
    SpaceSeparatedColorNotation: 32768,
    FontFamilySystemUi: 65536,
    DoublePositionGradients: 131072,
    VendorPrefixes: 262144,
    LogicalProperties: 524288,
    LightDark: 1048576,
    Selectors: 31,
    MediaQueries: 448,
    Colors: 1113088
};
}),
"[project]/node_modules/lightningcss/node/index.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

let parts = [
    process.platform,
    process.arch
];
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
if (process.env.CSS_TRANSFORMER_WASM) {
    module.exports = (()=>{
        const e = new Error("Cannot find module '../pkg'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })();
} else {
    try {
        module.exports = __turbopack_context__.f({
            "lightningcss-darwin-arm64": {
                id: ()=>(()=>{
                        throw new Error('could not resolve "' + `lightningcss-${parts.join('-')}` + '" into a module');
                    })(),
                module: ()=>(()=>{
                        throw new Error('could not resolve "' + `lightningcss-${parts.join('-')}` + '" into a module');
                    })()
            },
            "lightningcss-wasm": {
                id: ()=>"[project]/node_modules/lightningcss-wasm/wasm-node.cjs [postcss] (ecmascript)",
                module: ()=>__turbopack_context__.r("[project]/node_modules/lightningcss-wasm/wasm-node.cjs [postcss] (ecmascript)")
            }
        })(`lightningcss-${parts.join('-')}`);
    } catch (err) {
        module.exports = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    }
}
module.exports.browserslistToTargets = __turbopack_context__.r("[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)");
module.exports.composeVisitors = __turbopack_context__.r("[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)");
module.exports.Features = __turbopack_context__.r("[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)").Features;
}),
"[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Features",
    ()=>Features,
    "browserslistToTargets",
    ()=>browserslistToTargets,
    "bundle",
    ()=>bundle,
    "bundleAsync",
    ()=>bundleAsync,
    "composeVisitors",
    ()=>composeVisitors,
    "transform",
    ()=>transform,
    "transformStyleAttribute",
    ()=>transformStyleAttribute
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.js [postcss] (ecmascript)");
;
const { transform, transformStyleAttribute, bundle, bundleAsync, browserslistToTargets, composeVisitors, Features } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"];
;
}),
"[project]/node_modules/magic-string/dist/magic-string.es.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Bundle",
    ()=>Bundle,
    "SourceMap",
    ()=>SourceMap,
    "default",
    ()=>MagicString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)");
;
class BitSet {
    constructor(arg){
        this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
    }
    add(n) {
        this.bits[n >> 5] |= 1 << (n & 31);
    }
    has(n) {
        return !!(this.bits[n >> 5] & 1 << (n & 31));
    }
}
class Chunk {
    constructor(start, end, content){
        this.start = start;
        this.end = end;
        this.original = content;
        this.intro = '';
        this.outro = '';
        this.content = content;
        this.storeName = false;
        this.edited = false;
        {
            this.previous = null;
            this.next = null;
        }
    }
    appendLeft(content) {
        this.outro += content;
    }
    appendRight(content) {
        this.intro = this.intro + content;
    }
    clone() {
        const chunk = new Chunk(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
    }
    contains(index) {
        return this.start < index && index < this.end;
    }
    eachNext(fn) {
        let chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.next;
        }
    }
    eachPrevious(fn) {
        let chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.previous;
        }
    }
    edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
            this.intro = '';
            this.outro = '';
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
    }
    prependLeft(content) {
        this.outro = content + this.outro;
    }
    prependRight(content) {
        this.intro = content + this.intro;
    }
    reset() {
        this.intro = '';
        this.outro = '';
        if (this.edited) {
            this.content = this.original;
            this.storeName = false;
            this.edited = false;
        }
    }
    split(index) {
        const sliceIndex = index - this.start;
        const originalBefore = this.original.slice(0, sliceIndex);
        const originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        const newChunk = new Chunk(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = '';
        this.end = index;
        if (this.edited) {
            // after split we should save the edit content record into the correct chunk
            // to make sure sourcemap correct
            // For example:
            // '  test'.trim()
            //     split   -> '  ' + 'test'
            //    edit    -> '' + 'test'
            //    edit    -> 'test' + ''
            // TODO is this block necessary?...
            newChunk.edit('', false);
            this.content = '';
        } else {
            this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next) newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
    }
    toString() {
        return this.intro + this.content + this.outro;
    }
    trimEnd(rx) {
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return true;
        const trimmed = this.content.replace(rx, '');
        if (trimmed.length) {
            if (trimmed !== this.content) {
                this.split(this.start + trimmed.length).edit('', undefined, true);
                if (this.edited) {
                    // save the change, if it has been edited
                    this.edit(trimmed, this.storeName, true);
                }
            }
            return true;
        } else {
            this.edit('', undefined, true);
            this.intro = this.intro.replace(rx, '');
            if (this.intro.length) return true;
        }
    }
    trimStart(rx) {
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return true;
        const trimmed = this.content.replace(rx, '');
        if (trimmed.length) {
            if (trimmed !== this.content) {
                const newChunk = this.split(this.end - trimmed.length);
                if (this.edited) {
                    // save the change, if it has been edited
                    newChunk.edit(trimmed, this.storeName, true);
                }
                this.edit('', undefined, true);
            }
            return true;
        } else {
            this.edit('', undefined, true);
            this.outro = this.outro.replace(rx, '');
            if (this.outro.length) return true;
        }
    }
}
function getBtoa() {
    if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
        return (str)=>globalThis.btoa(unescape(encodeURIComponent(str)));
    } else if (typeof Buffer === 'function') {
        return (str)=>Buffer.from(str, 'utf-8').toString('base64');
    } else {
        return ()=>{
            throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
        };
    }
}
const btoa = /*#__PURE__*/ getBtoa();
class SourceMap {
    constructor(properties){
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["encode"])(properties.mappings);
        if (typeof properties.x_google_ignoreList !== 'undefined') {
            this.x_google_ignoreList = properties.x_google_ignoreList;
        }
        if (typeof properties.debugId !== 'undefined') {
            this.debugId = properties.debugId;
        }
    }
    toString() {
        return JSON.stringify(this);
    }
    toUrl() {
        return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
    }
}
function guessIndent(code) {
    const lines = code.split('\n');
    const tabbed = lines.filter((line)=>/^\t+/.test(line));
    const spaced = lines.filter((line)=>/^ {2,}/.test(line));
    if (tabbed.length === 0 && spaced.length === 0) {
        return null;
    }
    // More lines tabbed than spaced? Assume tabs, and
    // default to tabs in the case of a tie (or nothing
    // to go on)
    if (tabbed.length >= spaced.length) {
        return '\t';
    }
    // Otherwise, we need to guess the multiple
    const min = spaced.reduce((previous, current)=>{
        const numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(' ');
}
function getRelativePath(from, to) {
    const fromParts = from.split(/[/\\]/);
    const toParts = to.split(/[/\\]/);
    fromParts.pop(); // get dirname
    while(fromParts[0] === toParts[0]){
        fromParts.shift();
        toParts.shift();
    }
    if (fromParts.length) {
        let i = fromParts.length;
        while(i--)fromParts[i] = '..';
    }
    return fromParts.concat(toParts).join('/');
}
const toString = Object.prototype.toString;
function isObject(thing) {
    return toString.call(thing) === '[object Object]';
}
function getLocator(source) {
    const originalLines = source.split('\n');
    const lineOffsets = [];
    for(let i = 0, pos = 0; i < originalLines.length; i++){
        lineOffsets.push(pos);
        pos += originalLines[i].length + 1;
    }
    return function locate(index) {
        let i = 0;
        let j = lineOffsets.length;
        while(i < j){
            const m = i + j >> 1;
            if (index < lineOffsets[m]) {
                j = m;
            } else {
                i = m + 1;
            }
        }
        const line = i - 1;
        const column = index - lineOffsets[line];
        return {
            line,
            column
        };
    };
}
const wordRegex = /\w/;
class Mappings {
    constructor(hires){
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
    }
    addEdit(sourceIndex, content, loc, nameIndex) {
        if (content.length) {
            const contentLengthMinusOne = content.length - 1;
            let contentLineEnd = content.indexOf('\n', 0);
            let previousContentLineEnd = -1;
            // Loop through each line in the content and add a segment, but stop if the last line is empty,
            // else code afterwards would fill one line too many
            while(contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd){
                const segment = [
                    this.generatedCodeColumn,
                    sourceIndex,
                    loc.line,
                    loc.column
                ];
                if (nameIndex >= 0) {
                    segment.push(nameIndex);
                }
                this.rawSegments.push(segment);
                this.generatedCodeLine += 1;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
                this.generatedCodeColumn = 0;
                previousContentLineEnd = contentLineEnd;
                contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
            }
            const segment = [
                this.generatedCodeColumn,
                sourceIndex,
                loc.line,
                loc.column
            ];
            if (nameIndex >= 0) {
                segment.push(nameIndex);
            }
            this.rawSegments.push(segment);
            this.advance(content.slice(previousContentLineEnd + 1));
        } else if (this.pending) {
            this.rawSegments.push(this.pending);
            this.advance(content);
        }
        this.pending = null;
    }
    addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        let originalCharIndex = chunk.start;
        let first = true;
        // when iterating each char, check if it's in a word boundary
        let charInHiresBoundary = false;
        while(originalCharIndex < chunk.end){
            if (original[originalCharIndex] === '\n') {
                loc.line += 1;
                loc.column = 0;
                this.generatedCodeLine += 1;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
                this.generatedCodeColumn = 0;
                first = true;
                charInHiresBoundary = false;
            } else {
                if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
                    const segment = [
                        this.generatedCodeColumn,
                        sourceIndex,
                        loc.line,
                        loc.column
                    ];
                    if (this.hires === 'boundary') {
                        // in hires "boundary", group segments per word boundary than per char
                        if (wordRegex.test(original[originalCharIndex])) {
                            // for first char in the boundary found, start the boundary by pushing a segment
                            if (!charInHiresBoundary) {
                                this.rawSegments.push(segment);
                                charInHiresBoundary = true;
                            }
                        } else {
                            // for non-word char, end the boundary by pushing a segment
                            this.rawSegments.push(segment);
                            charInHiresBoundary = false;
                        }
                    } else {
                        this.rawSegments.push(segment);
                    }
                }
                loc.column += 1;
                this.generatedCodeColumn += 1;
                first = false;
            }
            originalCharIndex += 1;
        }
        this.pending = null;
    }
    advance(str) {
        if (!str) return;
        const lines = str.split('\n');
        if (lines.length > 1) {
            for(let i = 0; i < lines.length - 1; i++){
                this.generatedCodeLine++;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
            }
            this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
    }
}
const n = '\n';
const warned = {
    insertLeft: false,
    insertRight: false,
    storeName: false
};
class MagicString {
    constructor(string, options = {}){
        const chunk = new Chunk(0, string.length, string);
        Object.defineProperties(this, {
            original: {
                writable: true,
                value: string
            },
            outro: {
                writable: true,
                value: ''
            },
            intro: {
                writable: true,
                value: ''
            },
            firstChunk: {
                writable: true,
                value: chunk
            },
            lastChunk: {
                writable: true,
                value: chunk
            },
            lastSearchedChunk: {
                writable: true,
                value: chunk
            },
            byStart: {
                writable: true,
                value: {}
            },
            byEnd: {
                writable: true,
                value: {}
            },
            filename: {
                writable: true,
                value: options.filename
            },
            indentExclusionRanges: {
                writable: true,
                value: options.indentExclusionRanges
            },
            sourcemapLocations: {
                writable: true,
                value: new BitSet()
            },
            storedNames: {
                writable: true,
                value: {}
            },
            indentStr: {
                writable: true,
                value: undefined
            },
            ignoreList: {
                writable: true,
                value: options.ignoreList
            },
            offset: {
                writable: true,
                value: options.offset || 0
            }
        });
        this.byStart[0] = chunk;
        this.byEnd[string.length] = chunk;
    }
    addSourcemapLocation(char) {
        this.sourcemapLocations.add(char);
    }
    append(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');
        this.outro += content;
        return this;
    }
    appendLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
            chunk.appendLeft(content);
        } else {
            this.intro += content;
        }
        return this;
    }
    appendRight(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
            chunk.appendRight(content);
        } else {
            this.outro += content;
        }
        return this;
    }
    clone() {
        const cloned = new MagicString(this.original, {
            filename: this.filename,
            offset: this.offset
        });
        let originalChunk = this.firstChunk;
        let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while(originalChunk){
            cloned.byStart[clonedChunk.start] = clonedChunk;
            cloned.byEnd[clonedChunk.end] = clonedChunk;
            const nextOriginalChunk = originalChunk.next;
            const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
            if (nextClonedChunk) {
                clonedChunk.next = nextClonedChunk;
                nextClonedChunk.previous = clonedChunk;
                clonedChunk = nextClonedChunk;
            }
            originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
            cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
        cloned.intro = this.intro;
        cloned.outro = this.outro;
        return cloned;
    }
    generateDecodedMap(options) {
        options = options || {};
        const sourceIndex = 0;
        const names = Object.keys(this.storedNames);
        const mappings = new Mappings(options.hires);
        const locate = getLocator(this.original);
        if (this.intro) {
            mappings.advance(this.intro);
        }
        this.firstChunk.eachNext((chunk)=>{
            const loc = locate(chunk.start);
            if (chunk.intro.length) mappings.advance(chunk.intro);
            if (chunk.edited) {
                mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
            } else {
                mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
            }
            if (chunk.outro.length) mappings.advance(chunk.outro);
        });
        if (this.outro) {
            mappings.advance(this.outro);
        }
        return {
            file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
            sources: [
                options.source ? getRelativePath(options.file || '', options.source) : options.file || ''
            ],
            sourcesContent: options.includeContent ? [
                this.original
            ] : undefined,
            names,
            mappings: mappings.raw,
            x_google_ignoreList: this.ignoreList ? [
                sourceIndex
            ] : undefined
        };
    }
    generateMap(options) {
        return new SourceMap(this.generateDecodedMap(options));
    }
    _ensureindentStr() {
        if (this.indentStr === undefined) {
            this.indentStr = guessIndent(this.original);
        }
    }
    _getRawIndentString() {
        this._ensureindentStr();
        return this.indentStr;
    }
    getIndentString() {
        this._ensureindentStr();
        return this.indentStr === null ? '\t' : this.indentStr;
    }
    indent(indentStr, options) {
        const pattern = /^[^\r\n]/gm;
        if (isObject(indentStr)) {
            options = indentStr;
            indentStr = undefined;
        }
        if (indentStr === undefined) {
            this._ensureindentStr();
            indentStr = this.indentStr || '\t';
        }
        if (indentStr === '') return this; // noop
        options = options || {};
        // Process exclusion ranges
        const isExcluded = {};
        if (options.exclude) {
            const exclusions = typeof options.exclude[0] === 'number' ? [
                options.exclude
            ] : options.exclude;
            exclusions.forEach((exclusion)=>{
                for(let i = exclusion[0]; i < exclusion[1]; i += 1){
                    isExcluded[i] = true;
                }
            });
        }
        let shouldIndentNextCharacter = options.indentStart !== false;
        const replacer = (match)=>{
            if (shouldIndentNextCharacter) return `${indentStr}${match}`;
            shouldIndentNextCharacter = true;
            return match;
        };
        this.intro = this.intro.replace(pattern, replacer);
        let charIndex = 0;
        let chunk = this.firstChunk;
        while(chunk){
            const end = chunk.end;
            if (chunk.edited) {
                if (!isExcluded[charIndex]) {
                    chunk.content = chunk.content.replace(pattern, replacer);
                    if (chunk.content.length) {
                        shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
                    }
                }
            } else {
                charIndex = chunk.start;
                while(charIndex < end){
                    if (!isExcluded[charIndex]) {
                        const char = this.original[charIndex];
                        if (char === '\n') {
                            shouldIndentNextCharacter = true;
                        } else if (char !== '\r' && shouldIndentNextCharacter) {
                            shouldIndentNextCharacter = false;
                            if (charIndex === chunk.start) {
                                chunk.prependRight(indentStr);
                            } else {
                                this._splitChunk(chunk, charIndex);
                                chunk = chunk.next;
                                chunk.prependRight(indentStr);
                            }
                        }
                    }
                    charIndex += 1;
                }
            }
            charIndex = chunk.end;
            chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern, replacer);
        return this;
    }
    insert() {
        throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
    }
    insertLeft(index, content) {
        if (!warned.insertLeft) {
            console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead');
            warned.insertLeft = true;
        }
        return this.appendLeft(index, content);
    }
    insertRight(index, content) {
        if (!warned.insertRight) {
            console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead');
            warned.insertRight = true;
        }
        return this.prependRight(index, content);
    }
    move(start, end, index) {
        start = start + this.offset;
        end = end + this.offset;
        index = index + this.offset;
        if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');
        this._split(start);
        this._split(end);
        this._split(index);
        const first = this.byStart[start];
        const last = this.byEnd[end];
        const oldLeft = first.previous;
        const oldRight = last.next;
        const newRight = this.byStart[index];
        if (!newRight && last === this.lastChunk) return this;
        const newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft) oldLeft.next = oldRight;
        if (oldRight) oldRight.previous = oldLeft;
        if (newLeft) newLeft.next = first;
        if (newRight) newRight.previous = last;
        if (!first.previous) this.firstChunk = last.next;
        if (!last.next) {
            this.lastChunk = first.previous;
            this.lastChunk.next = null;
        }
        first.previous = newLeft;
        last.next = newRight || null;
        if (!newLeft) this.firstChunk = first;
        if (!newRight) this.lastChunk = last;
        return this;
    }
    overwrite(start, end, content, options) {
        options = options || {};
        return this.update(start, end, content, {
            ...options,
            overwrite: !options.contentOnly
        });
    }
    update(start, end, content, options) {
        start = start + this.offset;
        end = end + this.offset;
        if (typeof content !== 'string') throw new TypeError('replacement content must be a string');
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (end > this.original.length) throw new Error('end is out of bounds');
        if (start === end) throw new Error('Cannot overwrite a zero-length range  use appendLeft or prependRight instead');
        this._split(start);
        this._split(end);
        if (options === true) {
            if (!warned.storeName) {
                console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string');
                warned.storeName = true;
            }
            options = {
                storeName: true
            };
        }
        const storeName = options !== undefined ? options.storeName : false;
        const overwrite = options !== undefined ? options.overwrite : false;
        if (storeName) {
            const original = this.original.slice(start, end);
            Object.defineProperty(this.storedNames, original, {
                writable: true,
                value: true,
                enumerable: true
            });
        }
        const first = this.byStart[start];
        const last = this.byEnd[end];
        if (first) {
            let chunk = first;
            while(chunk !== last){
                if (chunk.next !== this.byStart[chunk.end]) {
                    throw new Error('Cannot overwrite across a split point');
                }
                chunk = chunk.next;
                chunk.edit('', false);
            }
            first.edit(content, storeName, !overwrite);
        } else {
            // must be inserting at the end
            const newChunk = new Chunk(start, end, '').edit(content, storeName);
            // TODO last chunk in the array may not be the last chunk, if it's moved...
            last.next = newChunk;
            newChunk.previous = last;
        }
        return this;
    }
    prepend(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');
        this.intro = content + this.intro;
        return this;
    }
    prependLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
            chunk.prependLeft(content);
        } else {
            this.intro = content + this.intro;
        }
        return this;
    }
    prependRight(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
            chunk.prependRight(content);
        } else {
            this.outro = content + this.outro;
        }
        return this;
    }
    remove(start, end) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (start === end) return this;
        if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
        if (start > end) throw new Error('end must be greater than start');
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while(chunk){
            chunk.intro = '';
            chunk.outro = '';
            chunk.edit('');
            chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
    }
    reset(start, end) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (start === end) return this;
        if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
        if (start > end) throw new Error('end must be greater than start');
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while(chunk){
            chunk.reset();
            chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
    }
    lastChar() {
        if (this.outro.length) return this.outro[this.outro.length - 1];
        let chunk = this.lastChunk;
        do {
            if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
            if (chunk.content.length) return chunk.content[chunk.content.length - 1];
            if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
        }while (chunk = chunk.previous)
        if (this.intro.length) return this.intro[this.intro.length - 1];
        return '';
    }
    lastLine() {
        let lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
        let lineStr = this.outro;
        let chunk = this.lastChunk;
        do {
            if (chunk.outro.length > 0) {
                lineIndex = chunk.outro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.outro + lineStr;
            }
            if (chunk.content.length > 0) {
                lineIndex = chunk.content.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.content + lineStr;
            }
            if (chunk.intro.length > 0) {
                lineIndex = chunk.intro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.intro + lineStr;
            }
        }while (chunk = chunk.previous)
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
        return this.intro + lineStr;
    }
    slice(start = 0, end = this.original.length - this.offset) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        let result = '';
        // find start chunk
        let chunk = this.firstChunk;
        while(chunk && (chunk.start > start || chunk.end <= start)){
            // found end chunk before start
            if (chunk.start < end && chunk.end >= end) {
                return result;
            }
            chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
        const startChunk = chunk;
        while(chunk){
            if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
                result += chunk.intro;
            }
            const containsEnd = chunk.start < end && chunk.end >= end;
            if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
            const sliceStart = startChunk === chunk ? start - chunk.start : 0;
            const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
            result += chunk.content.slice(sliceStart, sliceEnd);
            if (chunk.outro && (!containsEnd || chunk.end === end)) {
                result += chunk.outro;
            }
            if (containsEnd) {
                break;
            }
            chunk = chunk.next;
        }
        return result;
    }
    // TODO deprecate this? not really very useful
    snip(start, end) {
        const clone = this.clone();
        clone.remove(0, start);
        clone.remove(end, clone.original.length);
        return clone;
    }
    _split(index) {
        if (this.byStart[index] || this.byEnd[index]) return;
        let chunk = this.lastSearchedChunk;
        let previousChunk = chunk;
        const searchForward = index > chunk.end;
        while(chunk){
            if (chunk.contains(index)) return this._splitChunk(chunk, index);
            chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
            // Prevent infinite loop (e.g. via empty chunks, where start === end)
            if (chunk === previousChunk) return;
            previousChunk = chunk;
        }
    }
    _splitChunk(chunk, index) {
        if (chunk.edited && chunk.content.length) {
            // zero-length edited chunks are a special case (overlapping replacements)
            const loc = getLocator(this.original)(index);
            throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column}  "${chunk.original}")`);
        }
        const newChunk = chunk.split(index);
        this.byEnd[index] = chunk;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk) this.lastChunk = newChunk;
        this.lastSearchedChunk = chunk;
        return true;
    }
    toString() {
        let str = this.intro;
        let chunk = this.firstChunk;
        while(chunk){
            str += chunk.toString();
            chunk = chunk.next;
        }
        return str + this.outro;
    }
    isEmpty() {
        let chunk = this.firstChunk;
        do {
            if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
        }while (chunk = chunk.next)
        return true;
    }
    length() {
        let chunk = this.firstChunk;
        let length = 0;
        do {
            length += chunk.intro.length + chunk.content.length + chunk.outro.length;
        }while (chunk = chunk.next)
        return length;
    }
    trimLines() {
        return this.trim('[\\r\\n]');
    }
    trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
    }
    trimEndAborted(charType) {
        const rx = new RegExp((charType || '\\s') + '+$');
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return true;
        let chunk = this.lastChunk;
        do {
            const end = chunk.end;
            const aborted = chunk.trimEnd(rx);
            // if chunk was trimmed, we have a new lastChunk
            if (chunk.end !== end) {
                if (this.lastChunk === chunk) {
                    this.lastChunk = chunk.next;
                }
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.previous;
        }while (chunk)
        return false;
    }
    trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
    }
    trimStartAborted(charType) {
        const rx = new RegExp('^' + (charType || '\\s') + '+');
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return true;
        let chunk = this.firstChunk;
        do {
            const end = chunk.end;
            const aborted = chunk.trimStart(rx);
            if (chunk.end !== end) {
                // special case...
                if (chunk === this.lastChunk) this.lastChunk = chunk.next;
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.next;
        }while (chunk)
        return false;
    }
    trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
    }
    hasChanged() {
        return this.original !== this.toString();
    }
    _replaceRegexp(searchValue, replacement) {
        function getReplacement(match, str) {
            if (typeof replacement === 'string') {
                return replacement.replace(/\$(\$|&|\d+)/g, (_, i)=>{
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
                    if (i === '$') return '$';
                    if (i === '&') return match[0];
                    const num = +i;
                    if (num < match.length) return match[+i];
                    return `$${i}`;
                });
            } else {
                return replacement(...match, match.index, str, match.groups);
            }
        }
        function matchAll(re, str) {
            let match;
            const matches = [];
            while(match = re.exec(str)){
                matches.push(match);
            }
            return matches;
        }
        if (searchValue.global) {
            const matches = matchAll(searchValue, this.original);
            matches.forEach((match)=>{
                if (match.index != null) {
                    const replacement = getReplacement(match, this.original);
                    if (replacement !== match[0]) {
                        this.overwrite(match.index, match.index + match[0].length, replacement);
                    }
                }
            });
        } else {
            const match = this.original.match(searchValue);
            if (match && match.index != null) {
                const replacement = getReplacement(match, this.original);
                if (replacement !== match[0]) {
                    this.overwrite(match.index, match.index + match[0].length, replacement);
                }
            }
        }
        return this;
    }
    _replaceString(string, replacement) {
        const { original } = this;
        const index = original.indexOf(string);
        if (index !== -1) {
            if (typeof replacement === 'function') {
                replacement = replacement(string, index, original);
            }
            if (string !== replacement) {
                this.overwrite(index, index + string.length, replacement);
            }
        }
        return this;
    }
    replace(searchValue, replacement) {
        if (typeof searchValue === 'string') {
            return this._replaceString(searchValue, replacement);
        }
        return this._replaceRegexp(searchValue, replacement);
    }
    _replaceAllString(string, replacement) {
        const { original } = this;
        const stringLength = string.length;
        for(let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)){
            const previous = original.slice(index, index + stringLength);
            let _replacement = replacement;
            if (typeof replacement === 'function') {
                _replacement = replacement(previous, index, original);
            }
            if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
        }
        return this;
    }
    replaceAll(searchValue, replacement) {
        if (typeof searchValue === 'string') {
            return this._replaceAllString(searchValue, replacement);
        }
        if (!searchValue.global) {
            throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument');
        }
        return this._replaceRegexp(searchValue, replacement);
    }
}
const hasOwnProp = Object.prototype.hasOwnProperty;
class Bundle {
    constructor(options = {}){
        this.intro = options.intro || '';
        this.separator = options.separator !== undefined ? options.separator : '\n';
        this.sources = [];
        this.uniqueSources = [];
        this.uniqueSourceIndexByFilename = {};
    }
    addSource(source) {
        if (source instanceof MagicString) {
            return this.addSource({
                content: source,
                filename: source.filename,
                separator: this.separator
            });
        }
        if (!isObject(source) || !source.content) {
            throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
        }
        [
            'filename',
            'ignoreList',
            'indentExclusionRanges',
            'separator'
        ].forEach((option)=>{
            if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
        });
        if (source.separator === undefined) {
            // TODO there's a bunch of this sort of thing, needs cleaning up
            source.separator = this.separator;
        }
        if (source.filename) {
            if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
                this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
                this.uniqueSources.push({
                    filename: source.filename,
                    content: source.content.original
                });
            } else {
                const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
                if (source.content.original !== uniqueSource.content) {
                    throw new Error(`Illegal source: same filename (${source.filename}), different contents`);
                }
            }
        }
        this.sources.push(source);
        return this;
    }
    append(str, options) {
        this.addSource({
            content: new MagicString(str),
            separator: options && options.separator || ''
        });
        return this;
    }
    clone() {
        const bundle = new Bundle({
            intro: this.intro,
            separator: this.separator
        });
        this.sources.forEach((source)=>{
            bundle.addSource({
                filename: source.filename,
                content: source.content.clone(),
                separator: source.separator
            });
        });
        return bundle;
    }
    generateDecodedMap(options = {}) {
        const names = [];
        let x_google_ignoreList = undefined;
        this.sources.forEach((source)=>{
            Object.keys(source.content.storedNames).forEach((name)=>{
                if (!~names.indexOf(name)) names.push(name);
            });
        });
        const mappings = new Mappings(options.hires);
        if (this.intro) {
            mappings.advance(this.intro);
        }
        this.sources.forEach((source, i)=>{
            if (i > 0) {
                mappings.advance(this.separator);
            }
            const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;
            const magicString = source.content;
            const locate = getLocator(magicString.original);
            if (magicString.intro) {
                mappings.advance(magicString.intro);
            }
            magicString.firstChunk.eachNext((chunk)=>{
                const loc = locate(chunk.start);
                if (chunk.intro.length) mappings.advance(chunk.intro);
                if (source.filename) {
                    if (chunk.edited) {
                        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
                    } else {
                        mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);
                    }
                } else {
                    mappings.advance(chunk.content);
                }
                if (chunk.outro.length) mappings.advance(chunk.outro);
            });
            if (magicString.outro) {
                mappings.advance(magicString.outro);
            }
            if (source.ignoreList && sourceIndex !== -1) {
                if (x_google_ignoreList === undefined) {
                    x_google_ignoreList = [];
                }
                x_google_ignoreList.push(sourceIndex);
            }
        });
        return {
            file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
            sources: this.uniqueSources.map((source)=>{
                return options.file ? getRelativePath(options.file, source.filename) : source.filename;
            }),
            sourcesContent: this.uniqueSources.map((source)=>{
                return options.includeContent ? source.content : null;
            }),
            names,
            mappings: mappings.raw,
            x_google_ignoreList
        };
    }
    generateMap(options) {
        return new SourceMap(this.generateDecodedMap(options));
    }
    getIndentString() {
        const indentStringCounts = {};
        this.sources.forEach((source)=>{
            const indentStr = source.content._getRawIndentString();
            if (indentStr === null) return;
            if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
            indentStringCounts[indentStr] += 1;
        });
        return Object.keys(indentStringCounts).sort((a, b)=>{
            return indentStringCounts[a] - indentStringCounts[b];
        })[0] || '\t';
    }
    indent(indentStr) {
        if (!arguments.length) {
            indentStr = this.getIndentString();
        }
        if (indentStr === '') return this; // noop
        let trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
        this.sources.forEach((source, i)=>{
            const separator = source.separator !== undefined ? source.separator : this.separator;
            const indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
            source.content.indent(indentStr, {
                exclude: source.indentExclusionRanges,
                indentStart
            });
            trailingNewline = source.content.lastChar() === '\n';
        });
        if (this.intro) {
            this.intro = indentStr + this.intro.replace(/^[^\n]/gm, (match, index)=>{
                return index > 0 ? indentStr + match : match;
            });
        }
        return this;
    }
    prepend(str) {
        this.intro = str + this.intro;
        return this;
    }
    toString() {
        const body = this.sources.map((source, i)=>{
            const separator = source.separator !== undefined ? source.separator : this.separator;
            const str = (i > 0 ? separator : '') + source.content.toString();
            return str;
        }).join('');
        return this.intro + body;
    }
    isEmpty() {
        if (this.intro.length && this.intro.trim()) return false;
        if (this.sources.some((source)=>!source.content.isEmpty())) return false;
        return true;
    }
    length() {
        return this.sources.reduce((length, source)=>length + source.content.length(), this.intro.length);
    }
    trimLines() {
        return this.trim('[\\r\\n]');
    }
    trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
    }
    trimStart(charType) {
        const rx = new RegExp('^' + (charType || '\\s') + '+');
        this.intro = this.intro.replace(rx, '');
        if (!this.intro) {
            let source;
            let i = 0;
            do {
                source = this.sources[i++];
                if (!source) {
                    break;
                }
            }while (!source.content.trimStartAborted(charType))
        }
        return this;
    }
    trimEnd(charType) {
        const rx = new RegExp((charType || '\\s') + '+$');
        let source;
        let i = this.sources.length - 1;
        do {
            source = this.sources[i--];
            if (!source) {
                this.intro = this.intro.replace(rx, '');
                break;
            }
        }while (!source.content.trimEndAborted(charType))
        return this;
    }
}
;
 //# sourceMappingURL=magic-string.es.mjs.map
}),
"[project]/node_modules/@tailwindcss/node/dist/esm-cache.loader.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolve",
    ()=>o
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@tailwindcss/node/dist/esm-cache.loader.mjs")}`;
    }
};
;
var o = async (a, e, u)=>{
    let r = await u(a, e);
    if (r.url === __TURBOPACK__import$2e$meta__.url || (0, __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["isBuiltin"])(r.url) || !e.parentURL) return r;
    let t = new URL(e.parentURL).searchParams.get("id");
    if (t === null) return r;
    let l = new URL(r.url);
    return l.searchParams.set("id", t), {
        ...r,
        url: `${l}`
    };
};
;
}),
"[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Instrumentation",
    ()=>bt,
    "__unstable__loadDesignSystem",
    ()=>ou,
    "compile",
    ()=>nu,
    "compileAst",
    ()=>iu,
    "env",
    ()=>ce,
    "loadModule",
    ()=>yt,
    "normalizePath",
    ()=>Ce,
    "optimize",
    ()=>pu,
    "toSourceMap",
    ()=>hu
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/enhanced-resolve/lib/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jiti/lib/jiti.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$lib$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/lib.mjs [postcss] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__e__as__$5f$_unstable_$5f$loadDesignSystem$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-MEY3PWYT.mjs [postcss] (ecmascript) <export e as __unstable__loadDesignSystem>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__d__as__compile$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-MEY3PWYT.mjs [postcss] (ecmascript) <export d as compile>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__c__as__compileAst$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-MEY3PWYT.mjs [postcss] (ecmascript) <export c as compileAst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-MEY3PWYT.mjs [postcss] (ecmascript) <export b as Features>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-MEY3PWYT.mjs [postcss] (ecmascript) <export a as Polyfills>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$remapping$2f$dist$2f$remapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/remapping/dist/remapping.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$magic$2d$string$2f$dist$2f$magic$2d$string$2e$es$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/magic-string/dist/magic-string.es.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$source$2d$map$2d$js$2f$source$2d$map$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@tailwindcss/node/dist/index.mjs")}`;
    }
};
var At = Object.defineProperty;
var Ct = (e, r)=>{
    for(var t in r)At(e, t, {
        get: r[t],
        enumerable: !0
    });
};
;
;
var ce = {};
Ct(ce, {
    DEBUG: ()=>fe
});
var fe = St(process.env.DEBUG);
function St(e) {
    if (typeof e == "boolean") return e;
    if (e === void 0) return !1;
    if (e === "true" || e === "1") return !0;
    if (e === "false" || e === "0") return !1;
    if (e === "*") return !0;
    let r = e.split(",").map((t)=>t.split(":")[0]);
    return r.includes("-tailwindcss") ? !1 : !!r.includes("tailwindcss");
}
;
;
;
;
;
;
;
;
;
var $t = [
    /import[\s\S]*?['"](.{3,}?)['"]/gi,
    /import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi,
    /export[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi,
    /require\(['"`](.+)['"`]\)/gi
], Tt = [
    ".js",
    ".cjs",
    ".mjs"
], Et = [
    "",
    ".js",
    ".cjs",
    ".mjs",
    ".ts",
    ".cts",
    ".mts",
    ".jsx",
    ".tsx"
], Nt = [
    "",
    ".ts",
    ".cts",
    ".mts",
    ".tsx",
    ".js",
    ".cjs",
    ".mjs",
    ".jsx"
];
async function Vt(e, r) {
    for (let t of r){
        let i = `${e}${t}`;
        if ((await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].stat(i).catch(()=>null))?.isFile()) return i;
    }
    for (let t of r){
        let i = `${e}/index${t}`;
        if (await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].access(i).then(()=>!0, ()=>!1)) return i;
    }
    return null;
}
async function Ve(e, r, t, i) {
    let o = Tt.includes(i) ? Et : Nt, a = await Vt(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(t, r), o);
    if (a === null || e.has(a)) return;
    e.add(a), t = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(a), i = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].extname(a);
    let n = await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].readFile(a, "utf-8"), s = [];
    for (let l of $t)for (let u of n.matchAll(l))u[1].startsWith(".") && s.push(Ve(e, u[1], t, i));
    await Promise.all(s);
}
async function Re(e) {
    let r = new Set;
    return await Ve(r, e, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(e), __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].extname(e)), Array.from(r);
}
;
function z(e) {
    return {
        kind: "word",
        value: e
    };
}
function Rt(e, r) {
    return {
        kind: "function",
        value: e,
        nodes: r
    };
}
function Ot(e) {
    return {
        kind: "separator",
        value: e
    };
}
function S(e) {
    let r = "";
    for (let t of e)switch(t.kind){
        case "word":
        case "separator":
            {
                r += t.value;
                break;
            }
        case "function":
            r += t.value + "(" + S(t.nodes) + ")";
    }
    return r;
}
var Oe = 92, Pt = 41, Pe = 58, _e = 44, _t = 34, Ie = 61, De = 62, Ue = 60, Le = 10, It = 40, Dt = 39, Ut = 47, Ke = 32, ze = 9;
function A(e) {
    e = e.replaceAll(`\r
`, `
`);
    let r = [], t = [], i = null, o = "", a;
    for(let n = 0; n < e.length; n++){
        let s = e.charCodeAt(n);
        switch(s){
            case Oe:
                {
                    o += e[n] + e[n + 1], n++;
                    break;
                }
            case Ut:
                {
                    if (o.length > 0) {
                        let u = z(o);
                        i ? i.nodes.push(u) : r.push(u), o = "";
                    }
                    let l = z(e[n]);
                    i ? i.nodes.push(l) : r.push(l);
                    break;
                }
            case Pe:
            case _e:
            case Ie:
            case De:
            case Ue:
            case Le:
            case Ke:
            case ze:
                {
                    if (o.length > 0) {
                        let c = z(o);
                        i ? i.nodes.push(c) : r.push(c), o = "";
                    }
                    let l = n, u = n + 1;
                    for(; u < e.length && (a = e.charCodeAt(u), !(a !== Pe && a !== _e && a !== Ie && a !== De && a !== Ue && a !== Le && a !== Ke && a !== ze)); u++);
                    n = u - 1;
                    let p = Ot(e.slice(l, u));
                    i ? i.nodes.push(p) : r.push(p);
                    break;
                }
            case Dt:
            case _t:
                {
                    let l = n;
                    for(let u = n + 1; u < e.length; u++)if (a = e.charCodeAt(u), a === Oe) u += 1;
                    else if (a === s) {
                        n = u;
                        break;
                    }
                    o += e.slice(l, n + 1);
                    break;
                }
            case It:
                {
                    let l = Rt(o, []);
                    o = "", i ? i.nodes.push(l) : r.push(l), t.push(l), i = l;
                    break;
                }
            case Pt:
                {
                    let l = t.pop();
                    if (o.length > 0) {
                        let u = z(o);
                        l?.nodes.push(u), o = "";
                    }
                    t.length > 0 ? i = t[t.length - 1] : i = null;
                    break;
                }
            default:
                o += String.fromCharCode(s);
        }
    }
    return o.length > 0 && r.push(z(o)), r;
}
var g = class extends Map {
    constructor(t){
        super();
        this.factory = t;
    }
    get(t) {
        let i = super.get(t);
        return i === void 0 && (i = this.factory(t, this), this.set(t, i)), i;
    }
};
var li = new Uint8Array(256);
var te = new Uint8Array(256);
function y(e, r) {
    let t = 0, i = [], o = 0, a = e.length, n = r.charCodeAt(0);
    for(let s = 0; s < a; s++){
        let l = e.charCodeAt(s);
        if (t === 0 && l === n) {
            i.push(e.slice(o, s)), o = s + 1;
            continue;
        }
        switch(l){
            case 92:
                s += 1;
                break;
            case 39:
            case 34:
                for(; ++s < a;){
                    let u = e.charCodeAt(s);
                    if (u === 92) {
                        s += 1;
                        continue;
                    }
                    if (u === l) break;
                }
                break;
            case 40:
                te[t] = 41, t++;
                break;
            case 91:
                te[t] = 93, t++;
                break;
            case 123:
                te[t] = 125, t++;
                break;
            case 93:
            case 125:
            case 41:
                t > 0 && l === te[t - 1] && t--;
                break;
        }
    }
    return i.push(e.slice(o)), i;
}
var de = ((n)=>(n[n.Continue = 0] = "Continue", n[n.Skip = 1] = "Skip", n[n.Stop = 2] = "Stop", n[n.Replace = 3] = "Replace", n[n.ReplaceSkip = 4] = "ReplaceSkip", n[n.ReplaceStop = 5] = "ReplaceStop", n))(de || {}), w = {
    Continue: {
        kind: 0
    },
    Skip: {
        kind: 1
    },
    Stop: {
        kind: 2
    },
    Replace: (e)=>({
            kind: 3,
            nodes: Array.isArray(e) ? e : [
                e
            ]
        }),
    ReplaceSkip: (e)=>({
            kind: 4,
            nodes: Array.isArray(e) ? e : [
                e
            ]
        }),
    ReplaceStop: (e)=>({
            kind: 5,
            nodes: Array.isArray(e) ? e : [
                e
            ]
        })
};
function v(e, r) {
    typeof r == "function" ? Me(e, r) : Me(e, r.enter, r.exit);
}
function Me(e, r = ()=>w.Continue, t = ()=>w.Continue) {
    let i = [
        [
            e,
            0,
            null
        ]
    ], o = {
        parent: null,
        depth: 0,
        path () {
            let a = [];
            for(let n = 1; n < i.length; n++){
                let s = i[n][2];
                s && a.push(s);
            }
            return a;
        }
    };
    for(; i.length > 0;){
        let a = i.length - 1, n = i[a], s = n[0], l = n[1], u = n[2];
        if (l >= s.length) {
            i.pop();
            continue;
        }
        if (o.parent = u, o.depth = a, l >= 0) {
            let m = s[l], d = r(m, o) ?? w.Continue;
            switch(d.kind){
                case 0:
                    {
                        m.nodes && m.nodes.length > 0 && i.push([
                            m.nodes,
                            0,
                            m
                        ]), n[1] = ~l;
                        continue;
                    }
                case 2:
                    return;
                case 1:
                    {
                        n[1] = ~l;
                        continue;
                    }
                case 3:
                    {
                        s.splice(l, 1, ...d.nodes);
                        continue;
                    }
                case 5:
                    {
                        s.splice(l, 1, ...d.nodes);
                        return;
                    }
                case 4:
                    {
                        s.splice(l, 1, ...d.nodes), n[1] += d.nodes.length;
                        continue;
                    }
                default:
                    throw new Error(`Invalid \`WalkAction.${de[d.kind] ?? `Unknown(${d.kind})`}\` in enter.`);
            }
        }
        let p = ~l, c = s[p], f = t(c, o) ?? w.Continue;
        switch(f.kind){
            case 0:
                n[1] = p + 1;
                continue;
            case 2:
                return;
            case 3:
                {
                    s.splice(p, 1, ...f.nodes), n[1] = p + f.nodes.length;
                    continue;
                }
            case 5:
                {
                    s.splice(p, 1, ...f.nodes);
                    return;
                }
            case 4:
                {
                    s.splice(p, 1, ...f.nodes), n[1] = p + f.nodes.length;
                    continue;
                }
            default:
                throw new Error(`Invalid \`WalkAction.${de[f.kind] ?? `Unknown(${f.kind})`}\` in exit.`);
        }
    }
}
var wi = new g((e)=>{
    let r = A(e), t = new Set;
    return v(r, (i, o)=>{
        let a = o.parent === null ? r : o.parent.nodes ?? [];
        if (i.kind === "word" && (i.value === "+" || i.value === "-" || i.value === "*" || i.value === "/")) {
            let n = a.indexOf(i) ?? -1;
            if (n === -1) return;
            let s = a[n - 1];
            if (s?.kind !== "separator" || s.value !== " ") return;
            let l = a[n + 1];
            if (l?.kind !== "separator" || l.value !== " ") return;
            t.add(s), t.add(l);
        } else i.kind === "separator" && i.value.length > 0 && i.value.trim() === "" ? (a[0] === i || a[a.length - 1] === i) && t.add(i) : i.kind === "separator" && i.value.trim() === "," && (i.value = ",");
    }), t.size > 0 && v(r, (i)=>{
        if (t.has(i)) return t.delete(i), w.ReplaceSkip([]);
    }), me(r), S(r);
});
var yi = new g((e)=>{
    let r = A(e);
    return r.length === 3 && r[0].kind === "word" && r[0].value === "&" && r[1].kind === "separator" && r[1].value === ":" && r[2].kind === "function" && r[2].value === "is" ? S(r[2].nodes) : e;
});
function me(e) {
    for (let r of e)switch(r.kind){
        case "function":
            {
                if (r.value === "url" || r.value.endsWith("_url")) {
                    r.value = j(r.value);
                    break;
                }
                if (r.value === "var" || r.value.endsWith("_var") || r.value === "theme" || r.value.endsWith("_theme")) {
                    r.value = j(r.value);
                    for(let t = 0; t < r.nodes.length; t++)me([
                        r.nodes[t]
                    ]);
                    break;
                }
                r.value = j(r.value), me(r.nodes);
                break;
            }
        case "separator":
            r.value = j(r.value);
            break;
        case "word":
            {
                (r.value[0] !== "-" || r.value[1] !== "-") && (r.value = j(r.value));
                break;
            }
        default:
            Lt(r);
    }
}
var ki = new g((e)=>{
    let r = A(e);
    return r.length === 1 && r[0].kind === "function" && r[0].value === "var";
});
function Lt(e) {
    throw new Error(`Unexpected value: ${e}`);
}
function j(e) {
    return e.replaceAll("_", String.raw`\_`).replaceAll(" ", "_");
}
var Kt = process.env.FEATURES_ENV !== "stable";
var R = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/, Vi = new RegExp(`^${R.source}$`);
var Ri = new RegExp(`^${R.source}%$`);
var Oi = new RegExp(`^${R.source}s*/s*${R.source}$`);
var zt = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
], Pi = new RegExp(`^${R.source}(${zt.join("|")})$`);
var Mt = [
    "deg",
    "rad",
    "grad",
    "turn"
], _i = new RegExp(`^${R.source}(${Mt.join("|")})$`);
var Ii = new RegExp(`^${R.source} +${R.source} +${R.source}$`);
function C(e) {
    let r = Number(e);
    return Number.isInteger(r) && r >= 0 && String(r) === String(e);
}
function W(e, r) {
    if (r === null) return e;
    let t = Number(r);
    return Number.isNaN(t) || (r = `${t * 100}%`), r === "100%" ? e : `color-mix(in oklab, ${e} ${r}, transparent)`;
}
var Wt = {
    "--alpha": Bt,
    "--spacing": Yt,
    "--theme": Gt,
    theme: qt
};
function Bt(e, r, t, ...i) {
    let [o, a] = y(t, "/").map((n)=>n.trim());
    if (!o || !a) throw new Error(`The --alpha(\u2026) function requires a color and an alpha value, e.g.: \`--alpha(${o || "var(--my-color)"} / ${a || "50%"})\``);
    if (i.length > 0) throw new Error(`The --alpha(\u2026) function only accepts one argument, e.g.: \`--alpha(${o || "var(--my-color)"} / ${a || "50%"})\``);
    return W(o, a);
}
function Yt(e, r, t, ...i) {
    if (!t) throw new Error("The --spacing(\u2026) function requires an argument, but received none.");
    if (i.length > 0) throw new Error(`The --spacing(\u2026) function only accepts a single argument, but received ${i.length + 1}.`);
    let o = e.theme.resolve(null, [
        "--spacing"
    ]);
    if (!o) throw new Error("The --spacing(\u2026) function requires that the `--spacing` theme variable exists, but it was not found.");
    return `calc(${o} * ${t})`;
}
function Gt(e, r, t, ...i) {
    if (!t.startsWith("--")) throw new Error("The --theme(\u2026) function can only be used with CSS variables from your theme.");
    let o = !1;
    t.endsWith(" inline") && (o = !0, t = t.slice(0, -7)), r.kind === "at-rule" && (o = !0);
    let a = e.resolveThemeValue(t, o);
    if (!a) {
        if (i.length > 0) return i.join(", ");
        throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`);
    }
    if (i.length === 0) return a;
    let n = i.join(", ");
    if (n === "initial") return a;
    if (a === "initial") return n;
    if (a.startsWith("var(") || a.startsWith("theme(") || a.startsWith("--theme(")) {
        let s = A(a);
        return Zt(s, n), S(s);
    }
    return a;
}
function qt(e, r, t, ...i) {
    t = Ht(t);
    let o = e.resolveThemeValue(t);
    if (!o && i.length > 0) return i.join(", ");
    if (!o) throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`);
    return o;
}
var rn = new RegExp(Object.keys(Wt).map((e)=>`${e}\\(`).join("|"));
function Ht(e) {
    if (e[0] !== "'" && e[0] !== '"') return e;
    let r = "", t = e[0];
    for(let i = 1; i < e.length - 1; i++){
        let o = e[i], a = e[i + 1];
        o === "\\" && (a === t || a === "\\") ? (r += a, i++) : r += o;
    }
    return r;
}
function Zt(e, r) {
    v(e, (t)=>{
        if (t.kind === "function" && !(t.value !== "var" && t.value !== "theme" && t.value !== "--theme")) if (t.nodes.length === 1) t.nodes.push({
            kind: "word",
            value: `, ${r}`
        });
        else {
            let i = t.nodes[t.nodes.length - 1];
            i.kind === "word" && i.value === "initial" && (i.value = r);
        }
    });
}
var Jt = /^(?<value>[-+]?(?:\d*\.)?\d+)(?<unit>[a-z]+|%)?$/i, Be = new g((e)=>{
    let r = Jt.exec(e);
    if (!r) return null;
    let t = r.groups?.value;
    if (t === void 0) return null;
    let i = Number(t);
    if (Number.isNaN(i)) return null;
    let o = r.groups?.unit;
    return o === void 0 ? [
        i,
        null
    ] : [
        i,
        o
    ];
});
function Ye(e, r = "top", t = "right", i = "bottom", o = "left") {
    return Ge(`${e}-${r}`, `${e}-${t}`, `${e}-${i}`, `${e}-${o}`);
}
function Ge(e = "top", r = "right", t = "bottom", i = "left") {
    return {
        1: [
            [
                e,
                0
            ],
            [
                r,
                0
            ],
            [
                t,
                0
            ],
            [
                i,
                0
            ]
        ],
        2: [
            [
                e,
                0
            ],
            [
                r,
                1
            ],
            [
                t,
                0
            ],
            [
                i,
                1
            ]
        ],
        3: [
            [
                e,
                0
            ],
            [
                r,
                1
            ],
            [
                t,
                2
            ],
            [
                i,
                1
            ]
        ],
        4: [
            [
                e,
                0
            ],
            [
                r,
                1
            ],
            [
                t,
                2
            ],
            [
                i,
                3
            ]
        ]
    };
}
function D(e, r) {
    return {
        1: [
            [
                e,
                0
            ],
            [
                r,
                0
            ]
        ],
        2: [
            [
                e,
                0
            ],
            [
                r,
                1
            ]
        ]
    };
}
var xn = {
    inset: Ge(),
    margin: Ye("margin"),
    padding: Ye("padding"),
    gap: D("row-gap", "column-gap")
}, An = {
    "inset-block": D("top", "bottom"),
    "inset-inline": D("left", "right"),
    "margin-block": D("margin-top", "margin-bottom"),
    "margin-inline": D("margin-left", "margin-right"),
    "padding-block": D("padding-top", "padding-bottom"),
    "padding-inline": D("padding-left", "padding-right")
};
var Jn = Symbol();
var Xn = Symbol();
var eo = Symbol();
var to = Symbol();
var ro = Symbol();
var io = Symbol();
var no = Symbol();
var oo = Symbol();
var ao = Symbol();
var lo = Symbol();
var so = Symbol();
var uo = Symbol();
var fo = Symbol();
var G = 92, ie = 47, ne = 42, Je = 34, Xe = 39, fr = 58, oe = 59, T = 10, ae = 13, q = 32, H = 9, et = 123, ve = 125, ke = 40, tt = 41, cr = 91, pr = 93, rt = 45, we = 64, dr = 33;
function Q(e, r) {
    let t = r?.from ? {
        file: r.from,
        code: e
    } : null;
    e[0] === "\uFEFF" && (e = " " + e.slice(1));
    let i = [], o = [], a = [], n = null, s = null, l = "", u = "", p = 0, c;
    for(let f = 0; f < e.length; f++){
        let m = e.charCodeAt(f);
        if (!(m === ae && (c = e.charCodeAt(f + 1), c === T))) if (m === G) l === "" && (p = f), l += e.slice(f, f + 2), f += 1;
        else if (m === ie && e.charCodeAt(f + 1) === ne) {
            let d = f;
            for(let h = f + 2; h < e.length; h++)if (c = e.charCodeAt(h), c === G) h += 1;
            else if (c === ne && e.charCodeAt(h + 1) === ie) {
                f = h + 1;
                break;
            }
            let x = e.slice(d, f + 1);
            if (x.charCodeAt(2) === dr) {
                let h = xe(x.slice(2, -2));
                o.push(h), t && (h.src = [
                    t,
                    d,
                    f + 1
                ], h.dst = [
                    t,
                    d,
                    f + 1
                ]);
            }
        } else if (m === Xe || m === Je) {
            let d = it(e, f, m);
            l += e.slice(f, d + 1), f = d;
        } else {
            if ((m === q || m === T || m === H) && (c = e.charCodeAt(f + 1)) && (c === q || c === T || c === H || c === ae && (c = e.charCodeAt(f + 2)) && c == T)) continue;
            if (m === T) {
                if (l.length === 0) continue;
                c = l.charCodeAt(l.length - 1), c !== q && c !== T && c !== H && (l += " ");
            } else if (m === rt && e.charCodeAt(f + 1) === rt && l.length === 0) {
                let d = "", x = f, h = -1;
                for(let k = f + 2; k < e.length; k++)if (c = e.charCodeAt(k), c === G) k += 1;
                else if (c === Xe || c === Je) k = it(e, k, c);
                else if (c === ie && e.charCodeAt(k + 1) === ne) {
                    for(let K = k + 2; K < e.length; K++)if (c = e.charCodeAt(K), c === G) K += 1;
                    else if (c === ne && e.charCodeAt(K + 1) === ie) {
                        k = K + 1;
                        break;
                    }
                } else if (h === -1 && c === fr) h = l.length + k - x;
                else if (c === oe && d.length === 0) {
                    l += e.slice(x, k), f = k;
                    break;
                } else if (c === ke) d += ")";
                else if (c === cr) d += "]";
                else if (c === et) d += "}";
                else if ((c === ve || e.length - 1 === k) && d.length === 0) {
                    f = k - 1, l += e.slice(x, k);
                    break;
                } else (c === tt || c === pr || c === ve) && d.length > 0 && e[k] === d[d.length - 1] && (d = d.slice(0, -1));
                let _ = ye(l, h);
                if (!_) throw new Error("Invalid custom property, expected a value");
                t && (_.src = [
                    t,
                    x,
                    f
                ], _.dst = [
                    t,
                    x,
                    f
                ]), n ? n.nodes.push(_) : i.push(_), l = "";
            } else if (m === oe && l.charCodeAt(0) === we) s = Z(l), t && (s.src = [
                t,
                p,
                f
            ], s.dst = [
                t,
                p,
                f
            ]), n ? n.nodes.push(s) : i.push(s), l = "", s = null;
            else if (m === oe && u[u.length - 1] !== ")") {
                let d = ye(l);
                if (!d) {
                    if (l.length === 0) continue;
                    throw new Error(`Invalid declaration: \`${l.trim()}\``);
                }
                t && (d.src = [
                    t,
                    p,
                    f
                ], d.dst = [
                    t,
                    p,
                    f
                ]), n ? n.nodes.push(d) : i.push(d), l = "";
            } else if (m === et && u[u.length - 1] !== ")") u += "}", s = O(l.trim()), t && (s.src = [
                t,
                p,
                f
            ], s.dst = [
                t,
                p,
                f
            ]), n && n.nodes.push(s), a.push(n), n = s, l = "", s = null;
            else if (m === ve && u[u.length - 1] !== ")") {
                if (u === "") throw new Error("Missing opening {");
                if (u = u.slice(0, -1), l.length > 0) if (l.charCodeAt(0) === we) s = Z(l), t && (s.src = [
                    t,
                    p,
                    f
                ], s.dst = [
                    t,
                    p,
                    f
                ]), n ? n.nodes.push(s) : i.push(s), l = "", s = null;
                else {
                    let x = l.indexOf(":");
                    if (n) {
                        let h = ye(l, x);
                        if (!h) throw new Error(`Invalid declaration: \`${l.trim()}\``);
                        t && (h.src = [
                            t,
                            p,
                            f
                        ], h.dst = [
                            t,
                            p,
                            f
                        ]), n.nodes.push(h);
                    }
                }
                let d = a.pop() ?? null;
                d === null && n && i.push(n), n = d, l = "", s = null;
            } else if (m === ke) u += ")", l += "(";
            else if (m === tt) {
                if (u[u.length - 1] !== ")") throw new Error("Missing opening (");
                u = u.slice(0, -1), l += ")";
            } else {
                if (l.length === 0 && (m === q || m === T || m === H)) continue;
                l === "" && (p = f), l += String.fromCharCode(m);
            }
        }
    }
    if (l.charCodeAt(0) === we) {
        let f = Z(l);
        t && (f.src = [
            t,
            p,
            e.length
        ], f.dst = [
            t,
            p,
            e.length
        ]), i.push(f);
    }
    if (u.length > 0 && n) {
        if (n.kind === "rule") throw new Error(`Missing closing } at ${n.selector}`);
        if (n.kind === "at-rule") throw new Error(`Missing closing } at ${n.name} ${n.params}`);
    }
    return o.length > 0 ? o.concat(i) : i;
}
function Z(e, r = []) {
    let t = e, i = "";
    for(let o = 5; o < e.length; o++){
        let a = e.charCodeAt(o);
        if (a === q || a === H || a === ke) {
            t = e.slice(0, o), i = e.slice(o);
            break;
        }
    }
    return $(t.trim(), i.trim(), r);
}
function ye(e, r = e.indexOf(":")) {
    if (r === -1) return null;
    let t = e.indexOf("!important", r + 1);
    return N(e.slice(0, r).trim(), e.slice(r + 1, t === -1 ? e.length : t).trim(), t !== -1);
}
function it(e, r, t) {
    let i;
    for(let o = r + 1; o < e.length; o++)if (i = e.charCodeAt(o), i === G) o += 1;
    else {
        if (i === t) return o;
        if (i === oe && (e.charCodeAt(o + 1) === T || e.charCodeAt(o + 1) === ae && e.charCodeAt(o + 2) === T)) throw new Error(`Unterminated string: ${e.slice(r, o + 1) + String.fromCharCode(t)}`);
        if (i === T || i === ae && e.charCodeAt(o + 1) === T) throw new Error(`Unterminated string: ${e.slice(r, o) + String.fromCharCode(t)}`);
    }
    return r;
}
var Ae = {
    inherit: "inherit",
    current: "currentcolor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "oklch(98.4% 0.003 247.858)",
        100: "oklch(96.8% 0.007 247.896)",
        200: "oklch(92.9% 0.013 255.508)",
        300: "oklch(86.9% 0.022 252.894)",
        400: "oklch(70.4% 0.04 256.788)",
        500: "oklch(55.4% 0.046 257.417)",
        600: "oklch(44.6% 0.043 257.281)",
        700: "oklch(37.2% 0.044 257.287)",
        800: "oklch(27.9% 0.041 260.031)",
        900: "oklch(20.8% 0.042 265.755)",
        950: "oklch(12.9% 0.042 264.695)"
    },
    gray: {
        50: "oklch(98.5% 0.002 247.839)",
        100: "oklch(96.7% 0.003 264.542)",
        200: "oklch(92.8% 0.006 264.531)",
        300: "oklch(87.2% 0.01 258.338)",
        400: "oklch(70.7% 0.022 261.325)",
        500: "oklch(55.1% 0.027 264.364)",
        600: "oklch(44.6% 0.03 256.802)",
        700: "oklch(37.3% 0.034 259.733)",
        800: "oklch(27.8% 0.033 256.848)",
        900: "oklch(21% 0.034 264.665)",
        950: "oklch(13% 0.028 261.692)"
    },
    zinc: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(96.7% 0.001 286.375)",
        200: "oklch(92% 0.004 286.32)",
        300: "oklch(87.1% 0.006 286.286)",
        400: "oklch(70.5% 0.015 286.067)",
        500: "oklch(55.2% 0.016 285.938)",
        600: "oklch(44.2% 0.017 285.786)",
        700: "oklch(37% 0.013 285.805)",
        800: "oklch(27.4% 0.006 286.033)",
        900: "oklch(21% 0.006 285.885)",
        950: "oklch(14.1% 0.005 285.823)"
    },
    neutral: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(97% 0 0)",
        200: "oklch(92.2% 0 0)",
        300: "oklch(87% 0 0)",
        400: "oklch(70.8% 0 0)",
        500: "oklch(55.6% 0 0)",
        600: "oklch(43.9% 0 0)",
        700: "oklch(37.1% 0 0)",
        800: "oklch(26.9% 0 0)",
        900: "oklch(20.5% 0 0)",
        950: "oklch(14.5% 0 0)"
    },
    stone: {
        50: "oklch(98.5% 0.001 106.423)",
        100: "oklch(97% 0.001 106.424)",
        200: "oklch(92.3% 0.003 48.717)",
        300: "oklch(86.9% 0.005 56.366)",
        400: "oklch(70.9% 0.01 56.259)",
        500: "oklch(55.3% 0.013 58.071)",
        600: "oklch(44.4% 0.011 73.639)",
        700: "oklch(37.4% 0.01 67.558)",
        800: "oklch(26.8% 0.007 34.298)",
        900: "oklch(21.6% 0.006 56.043)",
        950: "oklch(14.7% 0.004 49.25)"
    },
    red: {
        50: "oklch(97.1% 0.013 17.38)",
        100: "oklch(93.6% 0.032 17.717)",
        200: "oklch(88.5% 0.062 18.334)",
        300: "oklch(80.8% 0.114 19.571)",
        400: "oklch(70.4% 0.191 22.216)",
        500: "oklch(63.7% 0.237 25.331)",
        600: "oklch(57.7% 0.245 27.325)",
        700: "oklch(50.5% 0.213 27.518)",
        800: "oklch(44.4% 0.177 26.899)",
        900: "oklch(39.6% 0.141 25.723)",
        950: "oklch(25.8% 0.092 26.042)"
    },
    orange: {
        50: "oklch(98% 0.016 73.684)",
        100: "oklch(95.4% 0.038 75.164)",
        200: "oklch(90.1% 0.076 70.697)",
        300: "oklch(83.7% 0.128 66.29)",
        400: "oklch(75% 0.183 55.934)",
        500: "oklch(70.5% 0.213 47.604)",
        600: "oklch(64.6% 0.222 41.116)",
        700: "oklch(55.3% 0.195 38.402)",
        800: "oklch(47% 0.157 37.304)",
        900: "oklch(40.8% 0.123 38.172)",
        950: "oklch(26.6% 0.079 36.259)"
    },
    amber: {
        50: "oklch(98.7% 0.022 95.277)",
        100: "oklch(96.2% 0.059 95.617)",
        200: "oklch(92.4% 0.12 95.746)",
        300: "oklch(87.9% 0.169 91.605)",
        400: "oklch(82.8% 0.189 84.429)",
        500: "oklch(76.9% 0.188 70.08)",
        600: "oklch(66.6% 0.179 58.318)",
        700: "oklch(55.5% 0.163 48.998)",
        800: "oklch(47.3% 0.137 46.201)",
        900: "oklch(41.4% 0.112 45.904)",
        950: "oklch(27.9% 0.077 45.635)"
    },
    yellow: {
        50: "oklch(98.7% 0.026 102.212)",
        100: "oklch(97.3% 0.071 103.193)",
        200: "oklch(94.5% 0.129 101.54)",
        300: "oklch(90.5% 0.182 98.111)",
        400: "oklch(85.2% 0.199 91.936)",
        500: "oklch(79.5% 0.184 86.047)",
        600: "oklch(68.1% 0.162 75.834)",
        700: "oklch(55.4% 0.135 66.442)",
        800: "oklch(47.6% 0.114 61.907)",
        900: "oklch(42.1% 0.095 57.708)",
        950: "oklch(28.6% 0.066 53.813)"
    },
    lime: {
        50: "oklch(98.6% 0.031 120.757)",
        100: "oklch(96.7% 0.067 122.328)",
        200: "oklch(93.8% 0.127 124.321)",
        300: "oklch(89.7% 0.196 126.665)",
        400: "oklch(84.1% 0.238 128.85)",
        500: "oklch(76.8% 0.233 130.85)",
        600: "oklch(64.8% 0.2 131.684)",
        700: "oklch(53.2% 0.157 131.589)",
        800: "oklch(45.3% 0.124 130.933)",
        900: "oklch(40.5% 0.101 131.063)",
        950: "oklch(27.4% 0.072 132.109)"
    },
    green: {
        50: "oklch(98.2% 0.018 155.826)",
        100: "oklch(96.2% 0.044 156.743)",
        200: "oklch(92.5% 0.084 155.995)",
        300: "oklch(87.1% 0.15 154.449)",
        400: "oklch(79.2% 0.209 151.711)",
        500: "oklch(72.3% 0.219 149.579)",
        600: "oklch(62.7% 0.194 149.214)",
        700: "oklch(52.7% 0.154 150.069)",
        800: "oklch(44.8% 0.119 151.328)",
        900: "oklch(39.3% 0.095 152.535)",
        950: "oklch(26.6% 0.065 152.934)"
    },
    emerald: {
        50: "oklch(97.9% 0.021 166.113)",
        100: "oklch(95% 0.052 163.051)",
        200: "oklch(90.5% 0.093 164.15)",
        300: "oklch(84.5% 0.143 164.978)",
        400: "oklch(76.5% 0.177 163.223)",
        500: "oklch(69.6% 0.17 162.48)",
        600: "oklch(59.6% 0.145 163.225)",
        700: "oklch(50.8% 0.118 165.612)",
        800: "oklch(43.2% 0.095 166.913)",
        900: "oklch(37.8% 0.077 168.94)",
        950: "oklch(26.2% 0.051 172.552)"
    },
    teal: {
        50: "oklch(98.4% 0.014 180.72)",
        100: "oklch(95.3% 0.051 180.801)",
        200: "oklch(91% 0.096 180.426)",
        300: "oklch(85.5% 0.138 181.071)",
        400: "oklch(77.7% 0.152 181.912)",
        500: "oklch(70.4% 0.14 182.503)",
        600: "oklch(60% 0.118 184.704)",
        700: "oklch(51.1% 0.096 186.391)",
        800: "oklch(43.7% 0.078 188.216)",
        900: "oklch(38.6% 0.063 188.416)",
        950: "oklch(27.7% 0.046 192.524)"
    },
    cyan: {
        50: "oklch(98.4% 0.019 200.873)",
        100: "oklch(95.6% 0.045 203.388)",
        200: "oklch(91.7% 0.08 205.041)",
        300: "oklch(86.5% 0.127 207.078)",
        400: "oklch(78.9% 0.154 211.53)",
        500: "oklch(71.5% 0.143 215.221)",
        600: "oklch(60.9% 0.126 221.723)",
        700: "oklch(52% 0.105 223.128)",
        800: "oklch(45% 0.085 224.283)",
        900: "oklch(39.8% 0.07 227.392)",
        950: "oklch(30.2% 0.056 229.695)"
    },
    sky: {
        50: "oklch(97.7% 0.013 236.62)",
        100: "oklch(95.1% 0.026 236.824)",
        200: "oklch(90.1% 0.058 230.902)",
        300: "oklch(82.8% 0.111 230.318)",
        400: "oklch(74.6% 0.16 232.661)",
        500: "oklch(68.5% 0.169 237.323)",
        600: "oklch(58.8% 0.158 241.966)",
        700: "oklch(50% 0.134 242.749)",
        800: "oklch(44.3% 0.11 240.79)",
        900: "oklch(39.1% 0.09 240.876)",
        950: "oklch(29.3% 0.066 243.157)"
    },
    blue: {
        50: "oklch(97% 0.014 254.604)",
        100: "oklch(93.2% 0.032 255.585)",
        200: "oklch(88.2% 0.059 254.128)",
        300: "oklch(80.9% 0.105 251.813)",
        400: "oklch(70.7% 0.165 254.624)",
        500: "oklch(62.3% 0.214 259.815)",
        600: "oklch(54.6% 0.245 262.881)",
        700: "oklch(48.8% 0.243 264.376)",
        800: "oklch(42.4% 0.199 265.638)",
        900: "oklch(37.9% 0.146 265.522)",
        950: "oklch(28.2% 0.091 267.935)"
    },
    indigo: {
        50: "oklch(96.2% 0.018 272.314)",
        100: "oklch(93% 0.034 272.788)",
        200: "oklch(87% 0.065 274.039)",
        300: "oklch(78.5% 0.115 274.713)",
        400: "oklch(67.3% 0.182 276.935)",
        500: "oklch(58.5% 0.233 277.117)",
        600: "oklch(51.1% 0.262 276.966)",
        700: "oklch(45.7% 0.24 277.023)",
        800: "oklch(39.8% 0.195 277.366)",
        900: "oklch(35.9% 0.144 278.697)",
        950: "oklch(25.7% 0.09 281.288)"
    },
    violet: {
        50: "oklch(96.9% 0.016 293.756)",
        100: "oklch(94.3% 0.029 294.588)",
        200: "oklch(89.4% 0.057 293.283)",
        300: "oklch(81.1% 0.111 293.571)",
        400: "oklch(70.2% 0.183 293.541)",
        500: "oklch(60.6% 0.25 292.717)",
        600: "oklch(54.1% 0.281 293.009)",
        700: "oklch(49.1% 0.27 292.581)",
        800: "oklch(43.2% 0.232 292.759)",
        900: "oklch(38% 0.189 293.745)",
        950: "oklch(28.3% 0.141 291.089)"
    },
    purple: {
        50: "oklch(97.7% 0.014 308.299)",
        100: "oklch(94.6% 0.033 307.174)",
        200: "oklch(90.2% 0.063 306.703)",
        300: "oklch(82.7% 0.119 306.383)",
        400: "oklch(71.4% 0.203 305.504)",
        500: "oklch(62.7% 0.265 303.9)",
        600: "oklch(55.8% 0.288 302.321)",
        700: "oklch(49.6% 0.265 301.924)",
        800: "oklch(43.8% 0.218 303.724)",
        900: "oklch(38.1% 0.176 304.987)",
        950: "oklch(29.1% 0.149 302.717)"
    },
    fuchsia: {
        50: "oklch(97.7% 0.017 320.058)",
        100: "oklch(95.2% 0.037 318.852)",
        200: "oklch(90.3% 0.076 319.62)",
        300: "oklch(83.3% 0.145 321.434)",
        400: "oklch(74% 0.238 322.16)",
        500: "oklch(66.7% 0.295 322.15)",
        600: "oklch(59.1% 0.293 322.896)",
        700: "oklch(51.8% 0.253 323.949)",
        800: "oklch(45.2% 0.211 324.591)",
        900: "oklch(40.1% 0.17 325.612)",
        950: "oklch(29.3% 0.136 325.661)"
    },
    pink: {
        50: "oklch(97.1% 0.014 343.198)",
        100: "oklch(94.8% 0.028 342.258)",
        200: "oklch(89.9% 0.061 343.231)",
        300: "oklch(82.3% 0.12 346.018)",
        400: "oklch(71.8% 0.202 349.761)",
        500: "oklch(65.6% 0.241 354.308)",
        600: "oklch(59.2% 0.249 0.584)",
        700: "oklch(52.5% 0.223 3.958)",
        800: "oklch(45.9% 0.187 3.815)",
        900: "oklch(40.8% 0.153 2.432)",
        950: "oklch(28.4% 0.109 3.907)"
    },
    rose: {
        50: "oklch(96.9% 0.015 12.422)",
        100: "oklch(94.1% 0.03 12.58)",
        200: "oklch(89.2% 0.058 10.001)",
        300: "oklch(81% 0.117 11.638)",
        400: "oklch(71.2% 0.194 13.428)",
        500: "oklch(64.5% 0.246 16.439)",
        600: "oklch(58.6% 0.253 17.585)",
        700: "oklch(51.4% 0.222 16.935)",
        800: "oklch(45.5% 0.188 13.697)",
        900: "oklch(41% 0.159 10.272)",
        950: "oklch(27.1% 0.105 12.094)"
    }
};
function L(e) {
    return {
        __BARE_VALUE__: e
    };
}
var E = L((e)=>{
    if (C(e.value)) return e.value;
}), b = L((e)=>{
    if (C(e.value)) return `${e.value}%`;
}), P = L((e)=>{
    if (C(e.value)) return `${e.value}px`;
}), ot = L((e)=>{
    if (C(e.value)) return `${e.value}ms`;
}), le = L((e)=>{
    if (C(e.value)) return `${e.value}deg`;
}), wr = L((e)=>{
    if (e.fraction === null) return;
    let [r, t] = y(e.fraction, "/");
    if (!(!C(r) || !C(t))) return e.fraction;
}), at = L((e)=>{
    if (C(Number(e.value))) return `repeat(${e.value}, minmax(0, 1fr))`;
}), yr = {
    accentColor: ({ theme: e })=>e("colors"),
    animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
    },
    aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
    },
    aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9",
        ...wr
    },
    backdropBlur: ({ theme: e })=>e("blur"),
    backdropBrightness: ({ theme: e })=>({
            ...e("brightness"),
            ...b
        }),
    backdropContrast: ({ theme: e })=>({
            ...e("contrast"),
            ...b
        }),
    backdropGrayscale: ({ theme: e })=>({
            ...e("grayscale"),
            ...b
        }),
    backdropHueRotate: ({ theme: e })=>({
            ...e("hueRotate"),
            ...le
        }),
    backdropInvert: ({ theme: e })=>({
            ...e("invert"),
            ...b
        }),
    backdropOpacity: ({ theme: e })=>({
            ...e("opacity"),
            ...b
        }),
    backdropSaturate: ({ theme: e })=>({
            ...e("saturate"),
            ...b
        }),
    backdropSepia: ({ theme: e })=>({
            ...e("sepia"),
            ...b
        }),
    backgroundColor: ({ theme: e })=>e("colors"),
    backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: e })=>e("opacity"),
    backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
    },
    blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
    },
    borderColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    borderOpacity: ({ theme: e })=>e("opacity"),
    borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
    },
    borderSpacing: ({ theme: e })=>e("spacing"),
    borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
    },
    boxShadowColor: ({ theme: e })=>e("colors"),
    brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...b
    },
    caretColor: ({ theme: e })=>e("colors"),
    colors: ()=>({
            ...Ae
        }),
    columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        ...E
    },
    container: {},
    content: {
        none: "none"
    },
    contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...b
    },
    cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: e })=>e("borderColor"),
    divideOpacity: ({ theme: e })=>e("borderOpacity"),
    divideWidth: ({ theme: e })=>({
            ...e("borderWidth"),
            ...P
        }),
    dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: [
            "0 1px 2px rgb(0 0 0 / 0.1)",
            "0 1px 1px rgb(0 0 0 / 0.06)"
        ],
        md: [
            "0 4px 3px rgb(0 0 0 / 0.07)",
            "0 2px 2px rgb(0 0 0 / 0.06)"
        ],
        lg: [
            "0 10px 8px rgb(0 0 0 / 0.04)",
            "0 4px 3px rgb(0 0 0 / 0.1)"
        ],
        xl: [
            "0 20px 13px rgb(0 0 0 / 0.03)",
            "0 8px 5px rgb(0 0 0 / 0.08)"
        ],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
    },
    fill: ({ theme: e })=>e("colors"),
    flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
    },
    flexBasis: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            ...e("spacing")
        }),
    flexGrow: {
        0: "0",
        DEFAULT: "1",
        ...E
    },
    flexShrink: {
        0: "0",
        DEFAULT: "1",
        ...E
    },
    fontFamily: {
        sans: [
            "ui-sans-serif",
            "system-ui",
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
        ],
        serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
        ],
        mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
        ]
    },
    fontSize: {
        xs: [
            "0.75rem",
            {
                lineHeight: "1rem"
            }
        ],
        sm: [
            "0.875rem",
            {
                lineHeight: "1.25rem"
            }
        ],
        base: [
            "1rem",
            {
                lineHeight: "1.5rem"
            }
        ],
        lg: [
            "1.125rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        xl: [
            "1.25rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        "2xl": [
            "1.5rem",
            {
                lineHeight: "2rem"
            }
        ],
        "3xl": [
            "1.875rem",
            {
                lineHeight: "2.25rem"
            }
        ],
        "4xl": [
            "2.25rem",
            {
                lineHeight: "2.5rem"
            }
        ],
        "5xl": [
            "3rem",
            {
                lineHeight: "1"
            }
        ],
        "6xl": [
            "3.75rem",
            {
                lineHeight: "1"
            }
        ],
        "7xl": [
            "4.5rem",
            {
                lineHeight: "1"
            }
        ],
        "8xl": [
            "6rem",
            {
                lineHeight: "1"
            }
        ],
        "9xl": [
            "8rem",
            {
                lineHeight: "1"
            }
        ]
    },
    fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
    },
    gap: ({ theme: e })=>e("spacing"),
    gradientColorStops: ({ theme: e })=>e("colors"),
    gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%",
        ...b
    },
    grayscale: {
        0: "0",
        DEFAULT: "100%",
        ...b
    },
    gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...E
    },
    gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...E
    },
    gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...E
    },
    gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...E
    },
    gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...at
    },
    gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...at
    },
    height: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg",
        ...le
    },
    inset: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    invert: {
        0: "0",
        DEFAULT: "100%",
        ...b
    },
    keyframes: {
        spin: {
            to: {
                transform: "rotate(360deg)"
            }
        },
        ping: {
            "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
            }
        },
        pulse: {
            "50%": {
                opacity: ".5"
            }
        },
        bounce: {
            "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
        }
    },
    letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
    },
    lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
    },
    listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
    },
    listStyleImage: {
        none: "none"
    },
    margin: ({ theme: e })=>({
            auto: "auto",
            ...e("spacing")
        }),
    lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        ...E
    },
    maxHeight: ({ theme: e })=>({
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    maxWidth: ({ theme: e })=>({
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...e("spacing")
        }),
    minHeight: ({ theme: e })=>({
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    minWidth: ({ theme: e })=>({
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1",
        ...b
    },
    order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        ...E
    },
    outlineColor: ({ theme: e })=>e("colors"),
    outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    padding: ({ theme: e })=>e("spacing"),
    placeholderColor: ({ theme: e })=>e("colors"),
    placeholderOpacity: ({ theme: e })=>e("opacity"),
    ringColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    ringOffsetColor: ({ theme: e })=>e("colors"),
    ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    ringOpacity: ({ theme: e })=>({
            DEFAULT: "0.5",
            ...e("opacity")
        }),
    ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg",
        ...le
    },
    saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2",
        ...b
    },
    scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        ...b
    },
    screens: {
        sm: "40rem",
        md: "48rem",
        lg: "64rem",
        xl: "80rem",
        "2xl": "96rem"
    },
    scrollMargin: ({ theme: e })=>e("spacing"),
    scrollPadding: ({ theme: e })=>e("spacing"),
    sepia: {
        0: "0",
        DEFAULT: "100%",
        ...b
    },
    skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        ...le
    },
    space: ({ theme: e })=>e("spacing"),
    spacing: {
        px: "1px",
        0: "0px",
        .5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
    },
    stroke: ({ theme: e })=>({
            none: "none",
            ...e("colors")
        }),
    strokeWidth: {
        0: "0",
        1: "1",
        2: "2",
        ...E
    },
    supports: {},
    data: {},
    textColor: ({ theme: e })=>e("colors"),
    textDecorationColor: ({ theme: e })=>e("colors"),
    textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    textIndent: ({ theme: e })=>e("spacing"),
    textOpacity: ({ theme: e })=>e("opacity"),
    textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
    },
    transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...ot
    },
    transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...ot
    },
    transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
    },
    transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: e })=>({
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    size: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    width: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
    },
    zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50",
        ...E
    }
};
var br = 64;
function I(e, r = []) {
    return {
        kind: "rule",
        selector: e,
        nodes: r
    };
}
function $(e, r = "", t = []) {
    return {
        kind: "at-rule",
        name: e,
        params: r,
        nodes: t
    };
}
function O(e, r = []) {
    return e.charCodeAt(0) === br ? Z(e, r) : I(e, r);
}
function N(e, r, t = !1) {
    return {
        kind: "declaration",
        property: e,
        value: r,
        important: t
    };
}
function xe(e) {
    return {
        kind: "comment",
        value: e
    };
}
function U(e, r) {
    let t = 0, i = {
        file: null,
        code: ""
    };
    function o(n, s = 0) {
        let l = "", u = "  ".repeat(s);
        if (n.kind === "declaration") {
            if (l += `${u}${n.property}: ${n.value}${n.important ? " !important" : ""};
`, r) {
                t += u.length;
                let p = t;
                t += n.property.length, t += 2, t += n.value?.length ?? 0, n.important && (t += 11);
                let c = t;
                t += 2, n.dst = [
                    i,
                    p,
                    c
                ];
            }
        } else if (n.kind === "rule") {
            if (l += `${u}${n.selector} {
`, r) {
                t += u.length;
                let p = t;
                t += n.selector.length, t += 1;
                let c = t;
                n.dst = [
                    i,
                    p,
                    c
                ], t += 2;
            }
            for (let p of n.nodes)l += o(p, s + 1);
            l += `${u}}
`, r && (t += u.length, t += 2);
        } else if (n.kind === "at-rule") {
            if (n.nodes.length === 0) {
                let p = `${u}${n.name} ${n.params};
`;
                if (r) {
                    t += u.length;
                    let c = t;
                    t += n.name.length, t += 1, t += n.params.length;
                    let f = t;
                    t += 2, n.dst = [
                        i,
                        c,
                        f
                    ];
                }
                return p;
            }
            if (l += `${u}${n.name}${n.params ? ` ${n.params} ` : " "}{
`, r) {
                t += u.length;
                let p = t;
                t += n.name.length, n.params && (t += 1, t += n.params.length), t += 1;
                let c = t;
                n.dst = [
                    i,
                    p,
                    c
                ], t += 2;
            }
            for (let p of n.nodes)l += o(p, s + 1);
            l += `${u}}
`, r && (t += u.length, t += 2);
        } else if (n.kind === "comment") {
            if (l += `${u}/*${n.value}*/
`, r) {
                t += u.length;
                let p = t;
                t += 2 + n.value.length + 2;
                let c = t;
                n.dst = [
                    i,
                    p,
                    c
                ], t += 1;
            }
        } else if (n.kind === "context" || n.kind === "at-root") return "";
        return l;
    }
    let a = "";
    for (let n of e)a += o(n, 0);
    return i.code = a, a;
}
function xr(e, r) {
    if (typeof e != "string") throw new TypeError("expected path to be a string");
    if (e === "\\" || e === "/") return "/";
    var t = e.length;
    if (t <= 1) return e;
    var i = "";
    if (t > 4 && e[3] === "\\") {
        var o = e[2];
        (o === "?" || o === ".") && e.slice(0, 2) === "\\\\" && (e = e.slice(2), i = "//");
    }
    var a = e.split(/[/\\]+/);
    return r !== !1 && a[a.length - 1] === "" && a.pop(), i + a.join("/");
}
function Ce(e) {
    let r = xr(e);
    return e.startsWith("\\\\") && r.startsWith("/") && !r.startsWith("//") ? `/${r}` : r;
}
var $e = /(?<!@import\s+)(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/, lt = /(?<=image-set\()((?:[\w-]{1,256}\([^)]*\)|[^)])*)(?=\))/, Ar = /(?:gradient|element|cross-fade|image)\(/, Cr = /^\s*data:/i, Sr = /^([a-z]+:)?\/\//, $r = /^[A-Z_][.\w-]*\(/i, Tr = /(?:^|\s)(?<url>[\w-]+\([^)]*\)|"[^"]*"|'[^']*'|[^,]\S*[^,])\s*(?:\s(?<descriptor>\w[^,]+))?(?:,|$)/g, Er = /(?<!\\)"/g, Nr = /(?: |\\t|\\n|\\f|\\r)+/g, Vr = (e)=>Cr.test(e), Rr = (e)=>Sr.test(e);
async function st({ css: e, base: r, root: t }) {
    if (!e.includes("url(") && !e.includes("image-set(")) return e;
    let i = Q(e), o = [];
    function a(n) {
        if (n[0] === "/") return n;
        let s = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["posix"].join(Ce(r), n), l = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["posix"].relative(Ce(t), s);
        return l.startsWith(".") || (l = "./" + l), l;
    }
    return v(i, (n)=>{
        if (n.kind !== "declaration" || !n.value) return;
        let s = $e.test(n.value), l = lt.test(n.value);
        if (s || l) {
            let u = l ? Or : ut;
            o.push(u(n.value, a).then((p)=>{
                n.value = p;
            }));
        }
    }), o.length && await Promise.all(o), U(i);
}
function ut(e, r) {
    return ct(e, $e, async (t)=>{
        let [i, o] = t;
        return await ft(o.trim(), i, r);
    });
}
async function Or(e, r) {
    return await ct(e, lt, async (t)=>{
        let [, i] = t;
        return await _r(i, async ({ url: a })=>$e.test(a) ? await ut(a, r) : Ar.test(a) ? a : await ft(a, a, r));
    });
}
async function ft(e, r, t, i = "url") {
    let o = "", a = e[0];
    if ((a === '"' || a === "'") && (o = a, e = e.slice(1, -1)), Pr(e)) return r;
    let n = await t(e);
    return o === "" && n !== encodeURI(n) && (o = '"'), o === "'" && n.includes("'") && (o = '"'), o === '"' && n.includes('"') && (n = n.replace(Er, '\\"')), `${i}(${o}${n}${o})`;
}
function Pr(e, r) {
    return Rr(e) || Vr(e) || !e[0].match(/[\.a-zA-Z0-9_]/) || $r.test(e);
}
function _r(e, r) {
    return Promise.all(Ir(e).map(async ({ url: t, descriptor: i })=>({
            url: await r({
                url: t,
                descriptor: i
            }),
            descriptor: i
        }))).then(Dr);
}
function Ir(e) {
    let r = e.trim().replace(Nr, " ").replace(/\r?\n/, "").replace(/,\s+/, ", ").replaceAll(/\s+/g, " ").matchAll(Tr);
    return Array.from(r, ({ groups: t })=>({
            url: t?.url?.trim() ?? "",
            descriptor: t?.descriptor?.trim() ?? ""
        })).filter(({ url: t })=>!!t);
}
function Dr(e) {
    return e.map(({ url: r, descriptor: t })=>r + (t ? ` ${t}` : "")).join(", ");
}
async function ct(e, r, t) {
    let i, o = e, a = "";
    for(; i = r.exec(o);)a += o.slice(0, i.index), a += await t(i), o = o.slice(i.index + i[0].length);
    return a += o, a;
}
function vt({ base: e, from: r, polyfills: t, onDependency: i, shouldRewriteUrls: o, customCssResolver: a, customJsResolver: n }) {
    return {
        base: e,
        polyfills: t,
        from: r,
        async loadModule (s, l) {
            return yt(s, l, i, n);
        },
        async loadStylesheet (s, l) {
            let u = await kt(s, l, i, a);
            return o && (u.content = await st({
                css: u.content,
                root: e,
                base: u.base
            })), u;
        }
    };
}
async function wt(e, r) {
    if (e.root && e.root !== "none") {
        let t = /[*{]/, i = [];
        for (let a of e.root.pattern.split("/")){
            if (t.test(a)) break;
            i.push(a);
        }
        if (!await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].stat(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(r, i.join("/"))).then((a)=>a.isDirectory()).catch(()=>!1)) throw new Error(`The \`source(${e.root.pattern})\` does not exist`);
    }
}
async function iu(e, r) {
    let t = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__c__as__compileAst$3e$__["compileAst"])(e, vt(r));
    return await wt(t, r.base), t;
}
async function nu(e, r) {
    let t = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__d__as__compile$3e$__["compile"])(e, vt(r));
    return await wt(t, r.base), t;
}
async function ou(e, { base: r }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__e__as__$5f$_unstable_$5f$loadDesignSystem$3e$__["__unstable__loadDesignSystem"])(e, {
        base: r,
        async loadModule (t, i) {
            return yt(t, i, ()=>{});
        },
        async loadStylesheet (t, i) {
            return kt(t, i, ()=>{});
        }
    });
}
async function yt(e, r, t, i) {
    if (e[0] !== ".") {
        let s = await gt(e, r, i);
        if (!s) throw new Error(`Could not resolve '${e}' from '${r}'`);
        let l = await mt((0, __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["pathToFileURL"])(s).href);
        return {
            path: s,
            base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(s),
            module: l.default ?? l
        };
    }
    let o = await gt(e, r, i);
    if (!o) throw new Error(`Could not resolve '${e}' from '${r}'`);
    let [a, n] = await Promise.all([
        mt((0, __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["pathToFileURL"])(o).href + "?id=" + Date.now()),
        Re(o)
    ]);
    for (let s of n)t(s);
    return {
        path: o,
        base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(o),
        module: a.default ?? a
    };
}
async function kt(e, r, t, i) {
    let o = await Fr(e, r, i);
    if (!o) throw new Error(`Could not resolve '${e}' from '${r}'`);
    if (t(o), typeof globalThis.__tw_readFile == "function") {
        let n = await globalThis.__tw_readFile(o, "utf-8");
        if (n) return {
            path: o,
            base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(o),
            content: n
        };
    }
    let a = await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].readFile(o, "utf-8");
    return {
        path: o,
        base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(o),
        content: a
    };
}
var dt = null;
async function mt(e) {
    if (typeof globalThis.__tw_load == "function") {
        let r = await globalThis.__tw_load(e);
        if (r) return r;
    }
    try {
        return await Promise.resolve().then(()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        });
    } catch  {
        return dt ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["createJiti"])(__TURBOPACK__import$2e$meta__.url, {
            moduleCache: !1,
            fsCache: !1
        }), await dt.import(e);
    }
}
var Ne = [
    "node_modules",
    ...process.env.NODE_PATH ? [
        process.env.NODE_PATH
    ] : []
], Mr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".css"
    ],
    mainFields: [
        "style"
    ],
    conditionNames: [
        "style"
    ],
    modules: Ne
});
async function Fr(e, r, t) {
    if (typeof globalThis.__tw_resolve == "function") {
        let i = globalThis.__tw_resolve(e, r);
        if (i) return Promise.resolve(i);
    }
    if (t) {
        let i = await t(e, r);
        if (i) return i;
    }
    return Te(Mr, e, r);
}
var jr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".js",
        ".json",
        ".node",
        ".ts"
    ],
    conditionNames: [
        "node",
        "import"
    ],
    modules: Ne
}), Wr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".js",
        ".json",
        ".node",
        ".ts"
    ],
    conditionNames: [
        "node",
        "require"
    ],
    modules: Ne
});
async function gt(e, r, t) {
    if (typeof globalThis.__tw_resolve == "function") {
        let i = globalThis.__tw_resolve(e, r);
        if (i) return Promise.resolve(i);
    }
    if (t) {
        let i = await t(e, r);
        if (i) return i;
    }
    return Te(jr, e, r).catch(()=>Te(Wr, e, r));
}
function Te(e, r, t) {
    return new Promise((i, o)=>e.resolve({}, t, r, {}, (a, n)=>{
            if (a) return o(a);
            i(n);
        }));
}
Symbol.dispose ??= Symbol("Symbol.dispose");
Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
var bt = class {
    constructor(r = (t)=>void process.stderr.write(`${t}
`)){
        this.defaultFlush = r;
    }
    #r = new g(()=>({
            value: 0
        }));
    #t = new g(()=>({
            value: 0n
        }));
    #e = [];
    hit(r) {
        this.#r.get(r).value++;
    }
    start(r) {
        let t = this.#e.map((o)=>o.label).join("//"), i = `${t}${t.length === 0 ? "" : "//"}${r}`;
        this.#r.get(i).value++, this.#t.get(i), this.#e.push({
            id: i,
            label: r,
            namespace: t,
            value: process.hrtime.bigint()
        });
    }
    end(r) {
        let t = process.hrtime.bigint();
        if (this.#e[this.#e.length - 1].label !== r) throw new Error(`Mismatched timer label: \`${r}\`, expected \`${this.#e[this.#e.length - 1].label}\``);
        let i = this.#e.pop(), o = t - i.value;
        this.#t.get(i.id).value += o;
    }
    reset() {
        this.#r.clear(), this.#t.clear(), this.#e.splice(0);
    }
    report(r = this.defaultFlush) {
        let t = [], i = !1;
        for(let n = this.#e.length - 1; n >= 0; n--)this.end(this.#e[n].label);
        for (let [n, { value: s }] of this.#r.entries()){
            if (this.#t.has(n)) continue;
            t.length === 0 && (i = !0, t.push("Hits:"));
            let l = n.split("//").length;
            t.push(`${"  ".repeat(l)}${n} ${se(xt(`\xD7 ${s}`))}`);
        }
        this.#t.size > 0 && i && t.push(`
Timers:`);
        let o = -1 / 0, a = new Map;
        for (let [n, { value: s }] of this.#t){
            let l = `${(Number(s) / 1e6).toFixed(2)}ms`;
            a.set(n, l), o = Math.max(o, l.length);
        }
        for (let n of this.#t.keys()){
            let s = n.split("//").length;
            t.push(`${se(`[${a.get(n).padStart(o, " ")}]`)}${"  ".repeat(s - 1)}${s === 1 ? " " : se(" \u21B3 ")}${n.split("//").pop()} ${this.#r.get(n).value === 1 ? "" : se(xt(`\xD7 ${this.#r.get(n).value}`))}`.trimEnd());
        }
        r(`
${t.join(`
`)}
`), this.reset();
    }
    [Symbol.dispose]() {
        fe && this.report();
    }
};
function se(e) {
    return `\x1B[2m${e}\x1B[22m`;
}
function xt(e) {
    return `\x1B[34m${e}\x1B[39m`;
}
;
;
;
function pu(e, { file: r = "input.css", minify: t = !1, map: i } = {}) {
    function o(l, u) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["transform"])({
            filename: r,
            code: l,
            minify: t,
            sourceMap: typeof u < "u",
            inputSourceMap: u,
            drafts: {
                customMedia: !0
            },
            nonStandard: {
                deepSelectorCombinator: !0
            },
            include: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].Nesting | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].MediaQueries,
            exclude: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].LogicalProperties | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].DirSelector | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].LightDark,
            targets: {
                safari: 16 << 16 | 1024,
                ios_saf: 16 << 16 | 1024,
                firefox: 8388608,
                chrome: 7274496
            },
            errorRecovery: !0
        });
    }
    let a = o(Buffer.from(e), i);
    if (i = a.map?.toString(), a.warnings = a.warnings.filter((l)=>!/'(deep|slotted|global)' is not recognized as a valid pseudo-/.test(l.message)), a.warnings.length > 0) {
        let l = e.split(`
`), u = [
            `Found ${a.warnings.length} ${a.warnings.length === 1 ? "warning" : "warnings"} while optimizing generated CSS:`
        ];
        for (let [p, c] of a.warnings.entries()){
            u.push(""), a.warnings.length > 1 && u.push(`Issue #${p + 1}:`);
            let f = 2, m = Math.max(0, c.loc.line - f - 1), d = Math.min(l.length, c.loc.line + f), x = l.slice(m, d).map((h, _)=>m + _ + 1 === c.loc.line ? `${ee("\u2502")} ${h}` : ee(`\u2502 ${h}`));
            x.splice(c.loc.line - m, 0, `${ee("\u2506")}${" ".repeat(c.loc.column - 1)} ${qr(`${ee("^--")} ${c.message}`)}`, `${ee("\u2506")}`), u.push(...x);
        }
        u.push(""), console.warn(u.join(`
`));
    }
    a = o(a.code, i), i = a.map?.toString();
    let n = a.code.toString(), s = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$magic$2d$string$2f$dist$2f$magic$2d$string$2e$es$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"](n);
    if (s.replaceAll("@media not (", "@media not all and ("), i !== void 0 && s.hasChanged()) {
        let l = s.generateMap({
            source: "original",
            hires: "boundary"
        }).toString();
        i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$remapping$2f$dist$2f$remapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"])([
            l,
            i
        ], ()=>null).toString();
    }
    return n = s.toString(), {
        code: n,
        map: i
    };
}
function ee(e) {
    return `\x1B[2m${e}\x1B[22m`;
}
function qr(e) {
    return `\x1B[33m${e}\x1B[39m`;
}
;
function Zr(e) {
    let r = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$source$2d$map$2d$js$2f$source$2d$map$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["SourceMapGenerator"], t = 1, i = new g((o)=>({
            url: o?.url ?? `<unknown ${t++}>`,
            content: o?.content ?? "<none>"
        }));
    for (let o of e.mappings){
        let a = i.get(o.originalPosition?.source ?? null);
        r.addMapping({
            generated: o.generatedPosition,
            original: o.originalPosition,
            source: a.url,
            name: o.name
        }), r.setSourceContent(a.url, a.content);
    }
    return r.toString();
}
function hu(e) {
    let r = typeof e == "string" ? e : Zr(e);
    return {
        raw: r,
        get inline () {
            let t = "";
            return t += "/*# sourceMappingURL=data:application/json;base64,", t += Buffer.from(r, "utf-8").toString("base64"), t += ` */
`, t;
        }
    };
}
if (!process.versions.bun) {
    let e = __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["createRequire"](__TURBOPACK__import$2e$meta__.url);
    __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["register"]?.((0, __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["pathToFileURL"])("[project]/node_modules/@tailwindcss/node/dist/esm-cache.loader.mjs [postcss] (ecmascript)"));
}
;
}),
"[project]/node_modules/@tailwindcss/node/dist/require-cache.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var i = Object.defineProperty;
var a = Object.getOwnPropertyDescriptor;
var f = Object.getOwnPropertyNames;
var l = Object.prototype.hasOwnProperty;
var n = (r, e)=>{
    for(var t in e)i(r, t, {
        get: e[t],
        enumerable: !0
    });
}, u = (r, e, t, o)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let c of f(e))!l.call(r, c) && c !== t && i(r, c, {
        get: ()=>e[c],
        enumerable: !(o = a(e, c)) || o.enumerable
    });
    return r;
};
var h = (r)=>u(i({}, "__esModule", {
        value: !0
    }), r);
var d = {};
n(d, {
    clearRequireCache: ()=>q
});
module.exports = h(d);
function q(r) {
    for (let e of r)delete __turbopack_context__.c[e];
}
0 && (module.exports = {
    clearRequireCache
});
}),
"[project]/node_modules/@tailwindcss/oxide-darwin-arm64/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"@tailwindcss/oxide-darwin-arm64","version":"4.1.17","repository":{"type":"git","url":"git+https://github.com/tailwindlabs/tailwindcss.git","directory":"crates/node/npm/darwin-arm64"},"os":["darwin"],"cpu":["arm64"],"main":"tailwindcss-oxide.darwin-arm64.node","files":["tailwindcss-oxide.darwin-arm64.node"],"publishConfig":{"provenance":true,"access":"public"},"license":"MIT","engines":{"node":">= 10"}});}),
"[project]/node_modules/@tailwindcss/oxide/index.js [postcss] (ecmascript)", ((__turbopack_context__, module, exports) => {

// prettier-ignore
/* eslint-disable */ // @ts-nocheck
/* auto-generated by NAPI-RS */ const { readFileSync } = __turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)");
let nativeBinding = null;
const loadErrors = [];
const isMusl = ()=>{
    let musl = false;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return musl;
};
const isFileMusl = (f)=>f.includes('libc.musl-') || f.includes('ld-musl-');
const isMuslFromFilesystem = ()=>{
    try {
        return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl');
    } catch  {
        return null;
    }
};
const isMuslFromReport = ()=>{
    let report = null;
    if (typeof process.report?.getReport === 'function') {
        process.report.excludeNetwork = true;
        report = process.report.getReport();
    }
    if (!report) {
        return null;
    }
    if (report.header && report.header.glibcVersionRuntime) {
        return false;
    }
    if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
            return true;
        }
    }
    return false;
};
const isMuslFromChildProcess = ()=>{
    try {
        return __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)").execSync('ldd --version', {
            encoding: 'utf8'
        }).includes('musl');
    } catch (e) {
        // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
        return false;
    }
};
function requireNative() {
    if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
        try {
            return (()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (err) {
            loadErrors.push(err);
        }
    } else if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else if ("TURBOPACK compile-time truthy", 1) {
        try {
            return (()=>{
                const e = new Error("Cannot find module './tailwindcss-oxide.darwin-universal.node'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (e) {
            loadErrors.push(e);
        }
        try {
            const binding = (()=>{
                const e = new Error("Cannot find module '@tailwindcss/oxide-darwin-universal'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
            const bindingPackageVersion = (()=>{
                const e = new Error("Cannot find module '@tailwindcss/oxide-darwin-universal/package.json'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })().version;
            if (bindingPackageVersion !== '4.1.17' && process.env.NAPI_RS_ENFORCE_VERSION_CHECK && process.env.NAPI_RS_ENFORCE_VERSION_CHECK !== '0') {
                throw new Error(`Native binding package version mismatch, expected 4.1.17 but got ${bindingPackageVersion}. You can reinstall dependencies to fix this issue.`);
            }
            return binding;
        } catch (e) {
            loadErrors.push(e);
        }
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else if ("TURBOPACK compile-time truthy", 1) {
            try {
                return (()=>{
                    const e = new Error("Cannot find module './tailwindcss-oxide.darwin-arm64.node'");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })();
            } catch (e) {
                loadErrors.push(e);
            }
            try {
                const binding = (()=>{
                    throw new Error('could not resolve "' + '@tailwindcss/oxide-darwin-arm64' + '" into a module');
                })();
                const bindingPackageVersion = __turbopack_context__.r("[project]/node_modules/@tailwindcss/oxide-darwin-arm64/package.json (json)").version;
                if (bindingPackageVersion !== '4.1.17' && process.env.NAPI_RS_ENFORCE_VERSION_CHECK && process.env.NAPI_RS_ENFORCE_VERSION_CHECK !== '0') {
                    throw new Error(`Native binding package version mismatch, expected 4.1.17 but got ${bindingPackageVersion}. You can reinstall dependencies to fix this issue.`);
                }
                return binding;
            } catch (e) {
                loadErrors.push(e);
            }
        } else //TURBOPACK unreachable
        ;
    } else //TURBOPACK unreachable
    ;
}
nativeBinding = requireNative();
if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
    let wasiBinding = null;
    let wasiBindingError = null;
    try {
        wasiBinding = (()=>{
            const e = new Error("Cannot find module './tailwindcss-oxide.wasi.cjs'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
        nativeBinding = wasiBinding;
    } catch (err) {
        if (process.env.NAPI_RS_FORCE_WASI) {
            wasiBindingError = err;
        }
    }
    if (!nativeBinding) {
        try {
            wasiBinding = (()=>{
                const e = new Error("Cannot find module '@tailwindcss/oxide-wasm32-wasi'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
            nativeBinding = wasiBinding;
        } catch (err) {
            if (process.env.NAPI_RS_FORCE_WASI) {
                wasiBindingError.cause = err;
                loadErrors.push(err);
            }
        }
    }
    if (process.env.NAPI_RS_FORCE_WASI === 'error' && !wasiBinding) {
        const error = new Error('WASI binding not found and NAPI_RS_FORCE_WASI is set to error');
        error.cause = wasiBindingError;
        throw error;
    }
}
if (!nativeBinding) {
    if (loadErrors.length > 0) {
        throw new Error(`Cannot find native binding. ` + `npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). ` + 'Please try `npm i` again after removing both package-lock.json and node_modules directory.', {
            cause: loadErrors.reduce((err, cur)=>{
                cur.cause = err;
                return cur;
            })
        });
    }
    throw new Error(`Failed to load native binding`);
}
module.exports = nativeBinding;
module.exports.Scanner = nativeBinding.Scanner;
}),
"[project]/node_modules/@tailwindcss/postcss/dist/index.mjs [postcss] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Zl
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$alloc$2f$quick$2d$lru$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@alloc/quick-lru/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-MEY3PWYT.mjs [postcss] (ecmascript) <export b as Features>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-MEY3PWYT.mjs [postcss] (ecmascript) <export a as Polyfills>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$require$2d$cache$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/require-cache.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$oxide$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/oxide/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var pe = (e, r)=>(r = Symbol[e]) ? r : Symbol.for("Symbol." + e), de = (e)=>{
    throw TypeError(e);
};
var me = (e, r, t)=>{
    if (r != null) {
        typeof r != "object" && typeof r != "function" && de("Object expected");
        var o, l;
        t && (o = r[pe("asyncDispose")]), o === void 0 && (o = r[pe("dispose")], t && (l = o)), typeof o != "function" && de("Object not disposable"), l && (o = function() {
            try {
                l.call(this);
            } catch (n) {
                return Promise.reject(n);
            }
        }), e.push([
            t,
            o,
            r
        ]);
    } else t && e.push([
        t
    ]);
    return r;
}, ge = (e, r, t)=>{
    var o = typeof SuppressedError == "function" ? SuppressedError : function(i, a, u, s) {
        return s = Error(u), s.name = "SuppressedError", s.error = i, s.suppressed = a, s;
    }, l = (i)=>r = t ? new o(i, r, "An error was suppressed during disposal") : (t = !0, i), n = (i)=>{
        for(; i = e.pop();)try {
            var a = i[1] && i[1].call(i[2]);
            if (i[0]) return Promise.resolve(a).then(n, (u)=>(l(u), n()));
        } catch (u) {
            l(u);
        }
        if (t) throw r;
    };
    return n();
};
;
;
;
;
;
;
function M(e) {
    return {
        kind: "word",
        value: e
    };
}
function qe(e, r) {
    return {
        kind: "function",
        value: e,
        nodes: r
    };
}
function He(e) {
    return {
        kind: "separator",
        value: e
    };
}
function S(e) {
    let r = "";
    for (let t of e)switch(t.kind){
        case "word":
        case "separator":
            {
                r += t.value;
                break;
            }
        case "function":
            r += t.value + "(" + S(t.nodes) + ")";
    }
    return r;
}
var he = 92, Ze = 41, ve = 58, ke = 44, Qe = 34, we = 61, ye = 62, be = 60, xe = 10, Je = 40, Xe = 39, et = 47, Ae = 32, Ce = 9;
function A(e) {
    e = e.replaceAll(`\r
`, `
`);
    let r = [], t = [], o = null, l = "", n;
    for(let i = 0; i < e.length; i++){
        let a = e.charCodeAt(i);
        switch(a){
            case he:
                {
                    l += e[i] + e[i + 1], i++;
                    break;
                }
            case et:
                {
                    if (l.length > 0) {
                        let s = M(l);
                        o ? o.nodes.push(s) : r.push(s), l = "";
                    }
                    let u = M(e[i]);
                    o ? o.nodes.push(u) : r.push(u);
                    break;
                }
            case ve:
            case ke:
            case we:
            case ye:
            case be:
            case xe:
            case Ae:
            case Ce:
                {
                    if (l.length > 0) {
                        let c = M(l);
                        o ? o.nodes.push(c) : r.push(c), l = "";
                    }
                    let u = i, s = i + 1;
                    for(; s < e.length && (n = e.charCodeAt(s), !(n !== ve && n !== ke && n !== we && n !== ye && n !== be && n !== xe && n !== Ae && n !== Ce)); s++);
                    i = s - 1;
                    let f = He(e.slice(u, s));
                    o ? o.nodes.push(f) : r.push(f);
                    break;
                }
            case Xe:
            case Qe:
                {
                    let u = i;
                    for(let s = i + 1; s < e.length; s++)if (n = e.charCodeAt(s), n === he) s += 1;
                    else if (n === a) {
                        i = s;
                        break;
                    }
                    l += e.slice(u, i + 1);
                    break;
                }
            case Je:
                {
                    let u = qe(l, []);
                    l = "", o ? o.nodes.push(u) : r.push(u), t.push(u), o = u;
                    break;
                }
            case Ze:
                {
                    let u = t.pop();
                    if (l.length > 0) {
                        let s = M(l);
                        u?.nodes.push(s), l = "";
                    }
                    t.length > 0 ? o = t[t.length - 1] : o = null;
                    break;
                }
            default:
                l += String.fromCharCode(a);
        }
    }
    return l.length > 0 && r.push(M(l)), r;
}
var d = class extends Map {
    constructor(t){
        super();
        this.factory = t;
    }
    get(t) {
        let o = super.get(t);
        return o === void 0 && (o = this.factory(t, this), this.set(t, o)), o;
    }
};
var rr = new Uint8Array(256);
var G = new Uint8Array(256);
function w(e, r) {
    let t = 0, o = [], l = 0, n = e.length, i = r.charCodeAt(0);
    for(let a = 0; a < n; a++){
        let u = e.charCodeAt(a);
        if (t === 0 && u === i) {
            o.push(e.slice(l, a)), l = a + 1;
            continue;
        }
        switch(u){
            case 92:
                a += 1;
                break;
            case 39:
            case 34:
                for(; ++a < n;){
                    let s = e.charCodeAt(a);
                    if (s === 92) {
                        a += 1;
                        continue;
                    }
                    if (s === u) break;
                }
                break;
            case 40:
                G[t] = 41, t++;
                break;
            case 91:
                G[t] = 93, t++;
                break;
            case 123:
                G[t] = 125, t++;
                break;
            case 93:
            case 125:
            case 41:
                t > 0 && u === G[t - 1] && t--;
                break;
        }
    }
    return o.push(e.slice(l)), o;
}
var X = ((i)=>(i[i.Continue = 0] = "Continue", i[i.Skip = 1] = "Skip", i[i.Stop = 2] = "Stop", i[i.Replace = 3] = "Replace", i[i.ReplaceSkip = 4] = "ReplaceSkip", i[i.ReplaceStop = 5] = "ReplaceStop", i))(X || {}), h = {
    Continue: {
        kind: 0
    },
    Skip: {
        kind: 1
    },
    Stop: {
        kind: 2
    },
    Replace: (e)=>({
            kind: 3,
            nodes: Array.isArray(e) ? e : [
                e
            ]
        }),
    ReplaceSkip: (e)=>({
            kind: 4,
            nodes: Array.isArray(e) ? e : [
                e
            ]
        }),
    ReplaceStop: (e)=>({
            kind: 5,
            nodes: Array.isArray(e) ? e : [
                e
            ]
        })
};
function v(e, r) {
    typeof r == "function" ? Se(e, r) : Se(e, r.enter, r.exit);
}
function Se(e, r = ()=>h.Continue, t = ()=>h.Continue) {
    let o = [
        [
            e,
            0,
            null
        ]
    ], l = {
        parent: null,
        depth: 0,
        path () {
            let n = [];
            for(let i = 1; i < o.length; i++){
                let a = o[i][2];
                a && n.push(a);
            }
            return n;
        }
    };
    for(; o.length > 0;){
        let n = o.length - 1, i = o[n], a = i[0], u = i[1], s = i[2];
        if (u >= a.length) {
            o.pop();
            continue;
        }
        if (l.parent = s, l.depth = n, u >= 0) {
            let O = a[u], T = r(O, l) ?? h.Continue;
            switch(T.kind){
                case 0:
                    {
                        O.nodes && O.nodes.length > 0 && o.push([
                            O.nodes,
                            0,
                            O
                        ]), i[1] = ~u;
                        continue;
                    }
                case 2:
                    return;
                case 1:
                    {
                        i[1] = ~u;
                        continue;
                    }
                case 3:
                    {
                        a.splice(u, 1, ...T.nodes);
                        continue;
                    }
                case 5:
                    {
                        a.splice(u, 1, ...T.nodes);
                        return;
                    }
                case 4:
                    {
                        a.splice(u, 1, ...T.nodes), i[1] += T.nodes.length;
                        continue;
                    }
                default:
                    throw new Error(`Invalid \`WalkAction.${X[T.kind] ?? `Unknown(${T.kind})`}\` in enter.`);
            }
        }
        let f = ~u, c = a[f], m = t(c, l) ?? h.Continue;
        switch(m.kind){
            case 0:
                i[1] = f + 1;
                continue;
            case 2:
                return;
            case 3:
                {
                    a.splice(f, 1, ...m.nodes), i[1] = f + m.nodes.length;
                    continue;
                }
            case 5:
                {
                    a.splice(f, 1, ...m.nodes);
                    return;
                }
            case 4:
                {
                    a.splice(f, 1, ...m.nodes), i[1] = f + m.nodes.length;
                    continue;
                }
            default:
                throw new Error(`Invalid \`WalkAction.${X[m.kind] ?? `Unknown(${m.kind})`}\` in exit.`);
        }
    }
}
var dr = new d((e)=>{
    let r = A(e), t = new Set;
    return v(r, (o, l)=>{
        let n = l.parent === null ? r : l.parent.nodes ?? [];
        if (o.kind === "word" && (o.value === "+" || o.value === "-" || o.value === "*" || o.value === "/")) {
            let i = n.indexOf(o) ?? -1;
            if (i === -1) return;
            let a = n[i - 1];
            if (a?.kind !== "separator" || a.value !== " ") return;
            let u = n[i + 1];
            if (u?.kind !== "separator" || u.value !== " ") return;
            t.add(a), t.add(u);
        } else o.kind === "separator" && o.value.length > 0 && o.value.trim() === "" ? (n[0] === o || n[n.length - 1] === o) && t.add(o) : o.kind === "separator" && o.value.trim() === "," && (o.value = ",");
    }), t.size > 0 && v(r, (o)=>{
        if (t.has(o)) return t.delete(o), h.ReplaceSkip([]);
    }), ee(r), S(r);
});
var mr = new d((e)=>{
    let r = A(e);
    return r.length === 3 && r[0].kind === "word" && r[0].value === "&" && r[1].kind === "separator" && r[1].value === ":" && r[2].kind === "function" && r[2].value === "is" ? S(r[2].nodes) : e;
});
function ee(e) {
    for (let r of e)switch(r.kind){
        case "function":
            {
                if (r.value === "url" || r.value.endsWith("_url")) {
                    r.value = F(r.value);
                    break;
                }
                if (r.value === "var" || r.value.endsWith("_var") || r.value === "theme" || r.value.endsWith("_theme")) {
                    r.value = F(r.value);
                    for(let t = 0; t < r.nodes.length; t++)ee([
                        r.nodes[t]
                    ]);
                    break;
                }
                r.value = F(r.value), ee(r.nodes);
                break;
            }
        case "separator":
            r.value = F(r.value);
            break;
        case "word":
            {
                (r.value[0] !== "-" || r.value[1] !== "-") && (r.value = F(r.value));
                break;
            }
        default:
            tt(r);
    }
}
var gr = new d((e)=>{
    let r = A(e);
    return r.length === 1 && r[0].kind === "function" && r[0].value === "var";
});
function tt(e) {
    throw new Error(`Unexpected value: ${e}`);
}
function F(e) {
    return e.replaceAll("_", String.raw`\_`).replaceAll(" ", "_");
}
var rt = process.env.FEATURES_ENV !== "stable";
var R = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/, Sr = new RegExp(`^${R.source}$`);
var Tr = new RegExp(`^${R.source}%$`);
var $r = new RegExp(`^${R.source}s*/s*${R.source}$`);
var it = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
], Nr = new RegExp(`^${R.source}(${it.join("|")})$`);
var nt = [
    "deg",
    "rad",
    "grad",
    "turn"
], Er = new RegExp(`^${R.source}(${nt.join("|")})$`);
var Vr = new RegExp(`^${R.source} +${R.source} +${R.source}$`);
function C(e) {
    let r = Number(e);
    return Number.isInteger(r) && r >= 0 && String(r) === String(e);
}
function j(e, r) {
    if (r === null) return e;
    let t = Number(r);
    return Number.isNaN(t) || (r = `${t * 100}%`), r === "100%" ? e : `color-mix(in oklab, ${e} ${r}, transparent)`;
}
var lt = {
    "--alpha": st,
    "--spacing": ut,
    "--theme": ft,
    theme: ct
};
function st(e, r, t, ...o) {
    let [l, n] = w(t, "/").map((i)=>i.trim());
    if (!l || !n) throw new Error(`The --alpha(\u2026) function requires a color and an alpha value, e.g.: \`--alpha(${l || "var(--my-color)"} / ${n || "50%"})\``);
    if (o.length > 0) throw new Error(`The --alpha(\u2026) function only accepts one argument, e.g.: \`--alpha(${l || "var(--my-color)"} / ${n || "50%"})\``);
    return j(l, n);
}
function ut(e, r, t, ...o) {
    if (!t) throw new Error("The --spacing(\u2026) function requires an argument, but received none.");
    if (o.length > 0) throw new Error(`The --spacing(\u2026) function only accepts a single argument, but received ${o.length + 1}.`);
    let l = e.theme.resolve(null, [
        "--spacing"
    ]);
    if (!l) throw new Error("The --spacing(\u2026) function requires that the `--spacing` theme variable exists, but it was not found.");
    return `calc(${l} * ${t})`;
}
function ft(e, r, t, ...o) {
    if (!t.startsWith("--")) throw new Error("The --theme(\u2026) function can only be used with CSS variables from your theme.");
    let l = !1;
    t.endsWith(" inline") && (l = !0, t = t.slice(0, -7)), r.kind === "at-rule" && (l = !0);
    let n = e.resolveThemeValue(t, l);
    if (!n) {
        if (o.length > 0) return o.join(", ");
        throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`);
    }
    if (o.length === 0) return n;
    let i = o.join(", ");
    if (i === "initial") return n;
    if (n === "initial") return i;
    if (n.startsWith("var(") || n.startsWith("theme(") || n.startsWith("--theme(")) {
        let a = A(n);
        return dt(a, i), S(a);
    }
    return n;
}
function ct(e, r, t, ...o) {
    t = pt(t);
    let l = e.resolveThemeValue(t);
    if (!l && o.length > 0) return o.join(", ");
    if (!l) throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`);
    return l;
}
var Qr = new RegExp(Object.keys(lt).map((e)=>`${e}\\(`).join("|"));
function pt(e) {
    if (e[0] !== "'" && e[0] !== '"') return e;
    let r = "", t = e[0];
    for(let o = 1; o < e.length - 1; o++){
        let l = e[o], n = e[o + 1];
        l === "\\" && (n === t || n === "\\") ? (r += n, o++) : r += l;
    }
    return r;
}
function dt(e, r) {
    v(e, (t)=>{
        if (t.kind === "function" && !(t.value !== "var" && t.value !== "theme" && t.value !== "--theme")) if (t.nodes.length === 1) t.nodes.push({
            kind: "word",
            value: `, ${r}`
        });
        else {
            let o = t.nodes[t.nodes.length - 1];
            o.kind === "word" && o.value === "initial" && (o.value = r);
        }
    });
}
var gt = /^(?<value>[-+]?(?:\d*\.)?\d+)(?<unit>[a-z]+|%)?$/i, Ee = new d((e)=>{
    let r = gt.exec(e);
    if (!r) return null;
    let t = r.groups?.value;
    if (t === void 0) return null;
    let o = Number(t);
    if (Number.isNaN(o)) return null;
    let l = r.groups?.unit;
    return l === void 0 ? [
        o,
        null
    ] : [
        o,
        l
    ];
});
function Ve(e, r = "top", t = "right", o = "bottom", l = "left") {
    return Re(`${e}-${r}`, `${e}-${t}`, `${e}-${o}`, `${e}-${l}`);
}
function Re(e = "top", r = "right", t = "bottom", o = "left") {
    return {
        1: [
            [
                e,
                0
            ],
            [
                r,
                0
            ],
            [
                t,
                0
            ],
            [
                o,
                0
            ]
        ],
        2: [
            [
                e,
                0
            ],
            [
                r,
                1
            ],
            [
                t,
                0
            ],
            [
                o,
                1
            ]
        ],
        3: [
            [
                e,
                0
            ],
            [
                r,
                1
            ],
            [
                t,
                2
            ],
            [
                o,
                1
            ]
        ],
        4: [
            [
                e,
                0
            ],
            [
                r,
                1
            ],
            [
                t,
                2
            ],
            [
                o,
                3
            ]
        ]
    };
}
function L(e, r) {
    return {
        1: [
            [
                e,
                0
            ],
            [
                r,
                0
            ]
        ],
        2: [
            [
                e,
                0
            ],
            [
                r,
                1
            ]
        ]
    };
}
var hi = {
    inset: Re(),
    margin: Ve("margin"),
    padding: Ve("padding"),
    gap: L("row-gap", "column-gap")
}, vi = {
    "inset-block": L("top", "bottom"),
    "inset-inline": L("left", "right"),
    "margin-block": L("margin-top", "margin-bottom"),
    "margin-inline": L("margin-left", "margin-right"),
    "padding-block": L("padding-top", "padding-bottom"),
    "padding-inline": L("padding-left", "padding-right")
};
var Yi = Symbol();
var Gi = Symbol();
var qi = Symbol();
var Hi = Symbol();
var Zi = Symbol();
var Qi = Symbol();
var Ji = Symbol();
var Xi = Symbol();
var en = Symbol();
var tn = Symbol();
var rn = Symbol();
var nn = Symbol();
var on = Symbol();
var $t = 32, Nt = 9;
var Et = 40;
function De(e, r = []) {
    let t = e, o = "";
    for(let l = 5; l < e.length; l++){
        let n = e.charCodeAt(l);
        if (n === $t || n === Nt || n === Et) {
            t = e.slice(0, l), o = e.slice(l);
            break;
        }
    }
    return x(t.trim(), o.trim(), r);
}
var ne = {
    inherit: "inherit",
    current: "currentcolor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "oklch(98.4% 0.003 247.858)",
        100: "oklch(96.8% 0.007 247.896)",
        200: "oklch(92.9% 0.013 255.508)",
        300: "oklch(86.9% 0.022 252.894)",
        400: "oklch(70.4% 0.04 256.788)",
        500: "oklch(55.4% 0.046 257.417)",
        600: "oklch(44.6% 0.043 257.281)",
        700: "oklch(37.2% 0.044 257.287)",
        800: "oklch(27.9% 0.041 260.031)",
        900: "oklch(20.8% 0.042 265.755)",
        950: "oklch(12.9% 0.042 264.695)"
    },
    gray: {
        50: "oklch(98.5% 0.002 247.839)",
        100: "oklch(96.7% 0.003 264.542)",
        200: "oklch(92.8% 0.006 264.531)",
        300: "oklch(87.2% 0.01 258.338)",
        400: "oklch(70.7% 0.022 261.325)",
        500: "oklch(55.1% 0.027 264.364)",
        600: "oklch(44.6% 0.03 256.802)",
        700: "oklch(37.3% 0.034 259.733)",
        800: "oklch(27.8% 0.033 256.848)",
        900: "oklch(21% 0.034 264.665)",
        950: "oklch(13% 0.028 261.692)"
    },
    zinc: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(96.7% 0.001 286.375)",
        200: "oklch(92% 0.004 286.32)",
        300: "oklch(87.1% 0.006 286.286)",
        400: "oklch(70.5% 0.015 286.067)",
        500: "oklch(55.2% 0.016 285.938)",
        600: "oklch(44.2% 0.017 285.786)",
        700: "oklch(37% 0.013 285.805)",
        800: "oklch(27.4% 0.006 286.033)",
        900: "oklch(21% 0.006 285.885)",
        950: "oklch(14.1% 0.005 285.823)"
    },
    neutral: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(97% 0 0)",
        200: "oklch(92.2% 0 0)",
        300: "oklch(87% 0 0)",
        400: "oklch(70.8% 0 0)",
        500: "oklch(55.6% 0 0)",
        600: "oklch(43.9% 0 0)",
        700: "oklch(37.1% 0 0)",
        800: "oklch(26.9% 0 0)",
        900: "oklch(20.5% 0 0)",
        950: "oklch(14.5% 0 0)"
    },
    stone: {
        50: "oklch(98.5% 0.001 106.423)",
        100: "oklch(97% 0.001 106.424)",
        200: "oklch(92.3% 0.003 48.717)",
        300: "oklch(86.9% 0.005 56.366)",
        400: "oklch(70.9% 0.01 56.259)",
        500: "oklch(55.3% 0.013 58.071)",
        600: "oklch(44.4% 0.011 73.639)",
        700: "oklch(37.4% 0.01 67.558)",
        800: "oklch(26.8% 0.007 34.298)",
        900: "oklch(21.6% 0.006 56.043)",
        950: "oklch(14.7% 0.004 49.25)"
    },
    red: {
        50: "oklch(97.1% 0.013 17.38)",
        100: "oklch(93.6% 0.032 17.717)",
        200: "oklch(88.5% 0.062 18.334)",
        300: "oklch(80.8% 0.114 19.571)",
        400: "oklch(70.4% 0.191 22.216)",
        500: "oklch(63.7% 0.237 25.331)",
        600: "oklch(57.7% 0.245 27.325)",
        700: "oklch(50.5% 0.213 27.518)",
        800: "oklch(44.4% 0.177 26.899)",
        900: "oklch(39.6% 0.141 25.723)",
        950: "oklch(25.8% 0.092 26.042)"
    },
    orange: {
        50: "oklch(98% 0.016 73.684)",
        100: "oklch(95.4% 0.038 75.164)",
        200: "oklch(90.1% 0.076 70.697)",
        300: "oklch(83.7% 0.128 66.29)",
        400: "oklch(75% 0.183 55.934)",
        500: "oklch(70.5% 0.213 47.604)",
        600: "oklch(64.6% 0.222 41.116)",
        700: "oklch(55.3% 0.195 38.402)",
        800: "oklch(47% 0.157 37.304)",
        900: "oklch(40.8% 0.123 38.172)",
        950: "oklch(26.6% 0.079 36.259)"
    },
    amber: {
        50: "oklch(98.7% 0.022 95.277)",
        100: "oklch(96.2% 0.059 95.617)",
        200: "oklch(92.4% 0.12 95.746)",
        300: "oklch(87.9% 0.169 91.605)",
        400: "oklch(82.8% 0.189 84.429)",
        500: "oklch(76.9% 0.188 70.08)",
        600: "oklch(66.6% 0.179 58.318)",
        700: "oklch(55.5% 0.163 48.998)",
        800: "oklch(47.3% 0.137 46.201)",
        900: "oklch(41.4% 0.112 45.904)",
        950: "oklch(27.9% 0.077 45.635)"
    },
    yellow: {
        50: "oklch(98.7% 0.026 102.212)",
        100: "oklch(97.3% 0.071 103.193)",
        200: "oklch(94.5% 0.129 101.54)",
        300: "oklch(90.5% 0.182 98.111)",
        400: "oklch(85.2% 0.199 91.936)",
        500: "oklch(79.5% 0.184 86.047)",
        600: "oklch(68.1% 0.162 75.834)",
        700: "oklch(55.4% 0.135 66.442)",
        800: "oklch(47.6% 0.114 61.907)",
        900: "oklch(42.1% 0.095 57.708)",
        950: "oklch(28.6% 0.066 53.813)"
    },
    lime: {
        50: "oklch(98.6% 0.031 120.757)",
        100: "oklch(96.7% 0.067 122.328)",
        200: "oklch(93.8% 0.127 124.321)",
        300: "oklch(89.7% 0.196 126.665)",
        400: "oklch(84.1% 0.238 128.85)",
        500: "oklch(76.8% 0.233 130.85)",
        600: "oklch(64.8% 0.2 131.684)",
        700: "oklch(53.2% 0.157 131.589)",
        800: "oklch(45.3% 0.124 130.933)",
        900: "oklch(40.5% 0.101 131.063)",
        950: "oklch(27.4% 0.072 132.109)"
    },
    green: {
        50: "oklch(98.2% 0.018 155.826)",
        100: "oklch(96.2% 0.044 156.743)",
        200: "oklch(92.5% 0.084 155.995)",
        300: "oklch(87.1% 0.15 154.449)",
        400: "oklch(79.2% 0.209 151.711)",
        500: "oklch(72.3% 0.219 149.579)",
        600: "oklch(62.7% 0.194 149.214)",
        700: "oklch(52.7% 0.154 150.069)",
        800: "oklch(44.8% 0.119 151.328)",
        900: "oklch(39.3% 0.095 152.535)",
        950: "oklch(26.6% 0.065 152.934)"
    },
    emerald: {
        50: "oklch(97.9% 0.021 166.113)",
        100: "oklch(95% 0.052 163.051)",
        200: "oklch(90.5% 0.093 164.15)",
        300: "oklch(84.5% 0.143 164.978)",
        400: "oklch(76.5% 0.177 163.223)",
        500: "oklch(69.6% 0.17 162.48)",
        600: "oklch(59.6% 0.145 163.225)",
        700: "oklch(50.8% 0.118 165.612)",
        800: "oklch(43.2% 0.095 166.913)",
        900: "oklch(37.8% 0.077 168.94)",
        950: "oklch(26.2% 0.051 172.552)"
    },
    teal: {
        50: "oklch(98.4% 0.014 180.72)",
        100: "oklch(95.3% 0.051 180.801)",
        200: "oklch(91% 0.096 180.426)",
        300: "oklch(85.5% 0.138 181.071)",
        400: "oklch(77.7% 0.152 181.912)",
        500: "oklch(70.4% 0.14 182.503)",
        600: "oklch(60% 0.118 184.704)",
        700: "oklch(51.1% 0.096 186.391)",
        800: "oklch(43.7% 0.078 188.216)",
        900: "oklch(38.6% 0.063 188.416)",
        950: "oklch(27.7% 0.046 192.524)"
    },
    cyan: {
        50: "oklch(98.4% 0.019 200.873)",
        100: "oklch(95.6% 0.045 203.388)",
        200: "oklch(91.7% 0.08 205.041)",
        300: "oklch(86.5% 0.127 207.078)",
        400: "oklch(78.9% 0.154 211.53)",
        500: "oklch(71.5% 0.143 215.221)",
        600: "oklch(60.9% 0.126 221.723)",
        700: "oklch(52% 0.105 223.128)",
        800: "oklch(45% 0.085 224.283)",
        900: "oklch(39.8% 0.07 227.392)",
        950: "oklch(30.2% 0.056 229.695)"
    },
    sky: {
        50: "oklch(97.7% 0.013 236.62)",
        100: "oklch(95.1% 0.026 236.824)",
        200: "oklch(90.1% 0.058 230.902)",
        300: "oklch(82.8% 0.111 230.318)",
        400: "oklch(74.6% 0.16 232.661)",
        500: "oklch(68.5% 0.169 237.323)",
        600: "oklch(58.8% 0.158 241.966)",
        700: "oklch(50% 0.134 242.749)",
        800: "oklch(44.3% 0.11 240.79)",
        900: "oklch(39.1% 0.09 240.876)",
        950: "oklch(29.3% 0.066 243.157)"
    },
    blue: {
        50: "oklch(97% 0.014 254.604)",
        100: "oklch(93.2% 0.032 255.585)",
        200: "oklch(88.2% 0.059 254.128)",
        300: "oklch(80.9% 0.105 251.813)",
        400: "oklch(70.7% 0.165 254.624)",
        500: "oklch(62.3% 0.214 259.815)",
        600: "oklch(54.6% 0.245 262.881)",
        700: "oklch(48.8% 0.243 264.376)",
        800: "oklch(42.4% 0.199 265.638)",
        900: "oklch(37.9% 0.146 265.522)",
        950: "oklch(28.2% 0.091 267.935)"
    },
    indigo: {
        50: "oklch(96.2% 0.018 272.314)",
        100: "oklch(93% 0.034 272.788)",
        200: "oklch(87% 0.065 274.039)",
        300: "oklch(78.5% 0.115 274.713)",
        400: "oklch(67.3% 0.182 276.935)",
        500: "oklch(58.5% 0.233 277.117)",
        600: "oklch(51.1% 0.262 276.966)",
        700: "oklch(45.7% 0.24 277.023)",
        800: "oklch(39.8% 0.195 277.366)",
        900: "oklch(35.9% 0.144 278.697)",
        950: "oklch(25.7% 0.09 281.288)"
    },
    violet: {
        50: "oklch(96.9% 0.016 293.756)",
        100: "oklch(94.3% 0.029 294.588)",
        200: "oklch(89.4% 0.057 293.283)",
        300: "oklch(81.1% 0.111 293.571)",
        400: "oklch(70.2% 0.183 293.541)",
        500: "oklch(60.6% 0.25 292.717)",
        600: "oklch(54.1% 0.281 293.009)",
        700: "oklch(49.1% 0.27 292.581)",
        800: "oklch(43.2% 0.232 292.759)",
        900: "oklch(38% 0.189 293.745)",
        950: "oklch(28.3% 0.141 291.089)"
    },
    purple: {
        50: "oklch(97.7% 0.014 308.299)",
        100: "oklch(94.6% 0.033 307.174)",
        200: "oklch(90.2% 0.063 306.703)",
        300: "oklch(82.7% 0.119 306.383)",
        400: "oklch(71.4% 0.203 305.504)",
        500: "oklch(62.7% 0.265 303.9)",
        600: "oklch(55.8% 0.288 302.321)",
        700: "oklch(49.6% 0.265 301.924)",
        800: "oklch(43.8% 0.218 303.724)",
        900: "oklch(38.1% 0.176 304.987)",
        950: "oklch(29.1% 0.149 302.717)"
    },
    fuchsia: {
        50: "oklch(97.7% 0.017 320.058)",
        100: "oklch(95.2% 0.037 318.852)",
        200: "oklch(90.3% 0.076 319.62)",
        300: "oklch(83.3% 0.145 321.434)",
        400: "oklch(74% 0.238 322.16)",
        500: "oklch(66.7% 0.295 322.15)",
        600: "oklch(59.1% 0.293 322.896)",
        700: "oklch(51.8% 0.253 323.949)",
        800: "oklch(45.2% 0.211 324.591)",
        900: "oklch(40.1% 0.17 325.612)",
        950: "oklch(29.3% 0.136 325.661)"
    },
    pink: {
        50: "oklch(97.1% 0.014 343.198)",
        100: "oklch(94.8% 0.028 342.258)",
        200: "oklch(89.9% 0.061 343.231)",
        300: "oklch(82.3% 0.12 346.018)",
        400: "oklch(71.8% 0.202 349.761)",
        500: "oklch(65.6% 0.241 354.308)",
        600: "oklch(59.2% 0.249 0.584)",
        700: "oklch(52.5% 0.223 3.958)",
        800: "oklch(45.9% 0.187 3.815)",
        900: "oklch(40.8% 0.153 2.432)",
        950: "oklch(28.4% 0.109 3.907)"
    },
    rose: {
        50: "oklch(96.9% 0.015 12.422)",
        100: "oklch(94.1% 0.03 12.58)",
        200: "oklch(89.2% 0.058 10.001)",
        300: "oklch(81% 0.117 11.638)",
        400: "oklch(71.2% 0.194 13.428)",
        500: "oklch(64.5% 0.246 16.439)",
        600: "oklch(58.6% 0.253 17.585)",
        700: "oklch(51.4% 0.222 16.935)",
        800: "oklch(45.5% 0.188 13.697)",
        900: "oklch(41% 0.159 10.272)",
        950: "oklch(27.1% 0.105 12.094)"
    }
};
function z(e) {
    return {
        __BARE_VALUE__: e
    };
}
var N = z((e)=>{
    if (C(e.value)) return e.value;
}), b = z((e)=>{
    if (C(e.value)) return `${e.value}%`;
}), I = z((e)=>{
    if (C(e.value)) return `${e.value}px`;
}), Ke = z((e)=>{
    if (C(e.value)) return `${e.value}ms`;
}), Z = z((e)=>{
    if (C(e.value)) return `${e.value}deg`;
}), _t = z((e)=>{
    if (e.fraction === null) return;
    let [r, t] = w(e.fraction, "/");
    if (!(!C(r) || !C(t))) return e.fraction;
}), ze = z((e)=>{
    if (C(Number(e.value))) return `repeat(${e.value}, minmax(0, 1fr))`;
}), It = {
    accentColor: ({ theme: e })=>e("colors"),
    animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
    },
    aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
    },
    aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9",
        ..._t
    },
    backdropBlur: ({ theme: e })=>e("blur"),
    backdropBrightness: ({ theme: e })=>({
            ...e("brightness"),
            ...b
        }),
    backdropContrast: ({ theme: e })=>({
            ...e("contrast"),
            ...b
        }),
    backdropGrayscale: ({ theme: e })=>({
            ...e("grayscale"),
            ...b
        }),
    backdropHueRotate: ({ theme: e })=>({
            ...e("hueRotate"),
            ...Z
        }),
    backdropInvert: ({ theme: e })=>({
            ...e("invert"),
            ...b
        }),
    backdropOpacity: ({ theme: e })=>({
            ...e("opacity"),
            ...b
        }),
    backdropSaturate: ({ theme: e })=>({
            ...e("saturate"),
            ...b
        }),
    backdropSepia: ({ theme: e })=>({
            ...e("sepia"),
            ...b
        }),
    backgroundColor: ({ theme: e })=>e("colors"),
    backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: e })=>e("opacity"),
    backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
    },
    blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
    },
    borderColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    borderOpacity: ({ theme: e })=>e("opacity"),
    borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
    },
    borderSpacing: ({ theme: e })=>e("spacing"),
    borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...I
    },
    boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
    },
    boxShadowColor: ({ theme: e })=>e("colors"),
    brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...b
    },
    caretColor: ({ theme: e })=>e("colors"),
    colors: ()=>({
            ...ne
        }),
    columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        ...N
    },
    container: {},
    content: {
        none: "none"
    },
    contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...b
    },
    cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: e })=>e("borderColor"),
    divideOpacity: ({ theme: e })=>e("borderOpacity"),
    divideWidth: ({ theme: e })=>({
            ...e("borderWidth"),
            ...I
        }),
    dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: [
            "0 1px 2px rgb(0 0 0 / 0.1)",
            "0 1px 1px rgb(0 0 0 / 0.06)"
        ],
        md: [
            "0 4px 3px rgb(0 0 0 / 0.07)",
            "0 2px 2px rgb(0 0 0 / 0.06)"
        ],
        lg: [
            "0 10px 8px rgb(0 0 0 / 0.04)",
            "0 4px 3px rgb(0 0 0 / 0.1)"
        ],
        xl: [
            "0 20px 13px rgb(0 0 0 / 0.03)",
            "0 8px 5px rgb(0 0 0 / 0.08)"
        ],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
    },
    fill: ({ theme: e })=>e("colors"),
    flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
    },
    flexBasis: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            ...e("spacing")
        }),
    flexGrow: {
        0: "0",
        DEFAULT: "1",
        ...N
    },
    flexShrink: {
        0: "0",
        DEFAULT: "1",
        ...N
    },
    fontFamily: {
        sans: [
            "ui-sans-serif",
            "system-ui",
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
        ],
        serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
        ],
        mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
        ]
    },
    fontSize: {
        xs: [
            "0.75rem",
            {
                lineHeight: "1rem"
            }
        ],
        sm: [
            "0.875rem",
            {
                lineHeight: "1.25rem"
            }
        ],
        base: [
            "1rem",
            {
                lineHeight: "1.5rem"
            }
        ],
        lg: [
            "1.125rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        xl: [
            "1.25rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        "2xl": [
            "1.5rem",
            {
                lineHeight: "2rem"
            }
        ],
        "3xl": [
            "1.875rem",
            {
                lineHeight: "2.25rem"
            }
        ],
        "4xl": [
            "2.25rem",
            {
                lineHeight: "2.5rem"
            }
        ],
        "5xl": [
            "3rem",
            {
                lineHeight: "1"
            }
        ],
        "6xl": [
            "3.75rem",
            {
                lineHeight: "1"
            }
        ],
        "7xl": [
            "4.5rem",
            {
                lineHeight: "1"
            }
        ],
        "8xl": [
            "6rem",
            {
                lineHeight: "1"
            }
        ],
        "9xl": [
            "8rem",
            {
                lineHeight: "1"
            }
        ]
    },
    fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
    },
    gap: ({ theme: e })=>e("spacing"),
    gradientColorStops: ({ theme: e })=>e("colors"),
    gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%",
        ...b
    },
    grayscale: {
        0: "0",
        DEFAULT: "100%",
        ...b
    },
    gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...N
    },
    gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...N
    },
    gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...N
    },
    gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...N
    },
    gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...ze
    },
    gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...ze
    },
    height: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg",
        ...Z
    },
    inset: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    invert: {
        0: "0",
        DEFAULT: "100%",
        ...b
    },
    keyframes: {
        spin: {
            to: {
                transform: "rotate(360deg)"
            }
        },
        ping: {
            "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
            }
        },
        pulse: {
            "50%": {
                opacity: ".5"
            }
        },
        bounce: {
            "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
        }
    },
    letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
    },
    lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
    },
    listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
    },
    listStyleImage: {
        none: "none"
    },
    margin: ({ theme: e })=>({
            auto: "auto",
            ...e("spacing")
        }),
    lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        ...N
    },
    maxHeight: ({ theme: e })=>({
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    maxWidth: ({ theme: e })=>({
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...e("spacing")
        }),
    minHeight: ({ theme: e })=>({
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    minWidth: ({ theme: e })=>({
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1",
        ...b
    },
    order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        ...N
    },
    outlineColor: ({ theme: e })=>e("colors"),
    outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...I
    },
    outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...I
    },
    padding: ({ theme: e })=>e("spacing"),
    placeholderColor: ({ theme: e })=>e("colors"),
    placeholderOpacity: ({ theme: e })=>e("opacity"),
    ringColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    ringOffsetColor: ({ theme: e })=>e("colors"),
    ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...I
    },
    ringOpacity: ({ theme: e })=>({
            DEFAULT: "0.5",
            ...e("opacity")
        }),
    ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...I
    },
    rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg",
        ...Z
    },
    saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2",
        ...b
    },
    scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        ...b
    },
    screens: {
        sm: "40rem",
        md: "48rem",
        lg: "64rem",
        xl: "80rem",
        "2xl": "96rem"
    },
    scrollMargin: ({ theme: e })=>e("spacing"),
    scrollPadding: ({ theme: e })=>e("spacing"),
    sepia: {
        0: "0",
        DEFAULT: "100%",
        ...b
    },
    skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        ...Z
    },
    space: ({ theme: e })=>e("spacing"),
    spacing: {
        px: "1px",
        0: "0px",
        .5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
    },
    stroke: ({ theme: e })=>({
            none: "none",
            ...e("colors")
        }),
    strokeWidth: {
        0: "0",
        1: "1",
        2: "2",
        ...N
    },
    supports: {},
    data: {},
    textColor: ({ theme: e })=>e("colors"),
    textDecorationColor: ({ theme: e })=>e("colors"),
    textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...I
    },
    textIndent: ({ theme: e })=>e("spacing"),
    textOpacity: ({ theme: e })=>e("opacity"),
    textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...I
    },
    transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
    },
    transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Ke
    },
    transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Ke
    },
    transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
    },
    transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: e })=>({
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    size: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    width: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
    },
    zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50",
        ...N
    }
};
function oe(e) {
    let r = [
        0
    ];
    for(let l = 0; l < e.length; l++)e.charCodeAt(l) === 10 && r.push(l + 1);
    function t(l) {
        let n = 0, i = r.length;
        for(; i > 0;){
            let u = (i | 0) >> 1, s = n + u;
            r[s] <= l ? (n = s + 1, i = i - u - 1) : i = u;
        }
        n -= 1;
        let a = l - r[n];
        return {
            line: n + 1,
            column: a
        };
    }
    function o({ line: l, column: n }) {
        l -= 1, l = Math.min(Math.max(l, 0), r.length - 1);
        let i = r[l], a = r[l + 1] ?? i;
        return Math.min(Math.max(i + n, 0), a);
    }
    return {
        find: t,
        findOffset: o
    };
}
var Ut = 64;
function U(e, r = []) {
    return {
        kind: "rule",
        selector: e,
        nodes: r
    };
}
function x(e, r = "", t = []) {
    return {
        kind: "at-rule",
        name: e,
        params: r,
        nodes: t
    };
}
function P(e, r = []) {
    return e.charCodeAt(0) === Ut ? De(e, r) : U(e, r);
}
function $(e, r, t = !1) {
    return {
        kind: "declaration",
        property: e,
        value: r,
        important: t
    };
}
function H(e) {
    return {
        kind: "comment",
        value: e
    };
}
function K(e, r) {
    let t = 0, o = {
        file: null,
        code: ""
    };
    function l(i, a = 0) {
        let u = "", s = "  ".repeat(a);
        if (i.kind === "declaration") {
            if (u += `${s}${i.property}: ${i.value}${i.important ? " !important" : ""};
`, r) {
                t += s.length;
                let f = t;
                t += i.property.length, t += 2, t += i.value?.length ?? 0, i.important && (t += 11);
                let c = t;
                t += 2, i.dst = [
                    o,
                    f,
                    c
                ];
            }
        } else if (i.kind === "rule") {
            if (u += `${s}${i.selector} {
`, r) {
                t += s.length;
                let f = t;
                t += i.selector.length, t += 1;
                let c = t;
                i.dst = [
                    o,
                    f,
                    c
                ], t += 2;
            }
            for (let f of i.nodes)u += l(f, a + 1);
            u += `${s}}
`, r && (t += s.length, t += 2);
        } else if (i.kind === "at-rule") {
            if (i.nodes.length === 0) {
                let f = `${s}${i.name} ${i.params};
`;
                if (r) {
                    t += s.length;
                    let c = t;
                    t += i.name.length, t += 1, t += i.params.length;
                    let m = t;
                    t += 2, i.dst = [
                        o,
                        c,
                        m
                    ];
                }
                return f;
            }
            if (u += `${s}${i.name}${i.params ? ` ${i.params} ` : " "}{
`, r) {
                t += s.length;
                let f = t;
                t += i.name.length, i.params && (t += 1, t += i.params.length), t += 1;
                let c = t;
                i.dst = [
                    o,
                    f,
                    c
                ], t += 2;
            }
            for (let f of i.nodes)u += l(f, a + 1);
            u += `${s}}
`, r && (t += s.length, t += 2);
        } else if (i.kind === "comment") {
            if (u += `${s}/*${i.value}*/
`, r) {
                t += s.length;
                let f = t;
                t += 2 + i.value.length + 2;
                let c = t;
                i.dst = [
                    o,
                    f,
                    c
                ], t += 1;
            }
        } else if (i.kind === "context" || i.kind === "at-root") return "";
        return u;
    }
    let n = "";
    for (let i of e)n += l(i, 0);
    return o.code = n, n;
}
var Lt = 33;
function Me(e, r, t) {
    let o = new d((s)=>new e.Input(s.code, {
            map: t?.input.map,
            from: s.file ?? void 0
        })), l = new d((s)=>oe(s.code)), n = e.root();
    n.source = t;
    function i(s) {
        if (!s || !s[0]) return;
        let f = l.get(s[0]), c = f.find(s[1]), m = f.find(s[2]);
        return {
            input: o.get(s[0]),
            start: {
                line: c.line,
                column: c.column + 1,
                offset: s[1]
            },
            end: {
                line: m.line,
                column: m.column + 1,
                offset: s[2]
            }
        };
    }
    function a(s, f) {
        let c = i(f);
        c ? s.source = c : delete s.source;
    }
    function u(s, f) {
        if (s.kind === "declaration") {
            let c = e.decl({
                prop: s.property,
                value: s.value ?? "",
                important: s.important
            });
            a(c, s.src), f.append(c);
        } else if (s.kind === "rule") {
            let c = e.rule({
                selector: s.selector
            });
            a(c, s.src), c.raws.semicolon = !0, f.append(c);
            for (let m of s.nodes)u(m, c);
        } else if (s.kind === "at-rule") {
            let c = e.atRule({
                name: s.name.slice(1),
                params: s.params
            });
            a(c, s.src), c.raws.semicolon = !0, f.append(c);
            for (let m of s.nodes)u(m, c);
        } else if (s.kind === "comment") {
            let c = e.comment({
                text: s.value
            });
            c.raws.left = "", c.raws.right = "", a(c, s.src), f.append(c);
        } else s.kind === "at-root" || s.kind;
    }
    for (let s of r)u(s, n);
    return n;
}
function Fe(e) {
    let r = new d((n)=>({
            file: n.file ?? n.id ?? null,
            code: n.css
        }));
    function t(n) {
        let i = n.source;
        if (!i) return;
        let a = i.input;
        if (a && i.start !== void 0 && i.end !== void 0) return [
            r.get(a),
            i.start.offset,
            i.end.offset
        ];
    }
    function o(n, i) {
        if (n.type === "decl") {
            let a = $(n.prop, n.value, n.important);
            a.src = t(n), i.push(a);
        } else if (n.type === "rule") {
            let a = P(n.selector);
            a.src = t(n), n.each((u)=>o(u, a.nodes)), i.push(a);
        } else if (n.type === "atrule") {
            let a = x(`@${n.name}`, n.params);
            a.src = t(n), n.each((u)=>o(u, a.nodes)), i.push(a);
        } else if (n.type === "comment") {
            if (n.text.charCodeAt(0) !== Lt) return;
            let a = H(n.text);
            a.src = t(n), i.push(a);
        }
    }
    let l = [];
    return e.each((n)=>o(n, l)), l;
}
;
;
var ae = "'", le = '"';
function se() {
    let e = new WeakSet;
    function r(t) {
        let o = t.root().source?.input.file;
        if (!o) return;
        let l = t.source?.input.file;
        if (!l || e.has(t)) return;
        let n = t.params[0], i = n[0] === le && n[n.length - 1] === le ? le : n[0] === ae && n[n.length - 1] === ae ? ae : null;
        if (!i) return;
        let a = t.params.slice(1, -1), u = "";
        if (a.startsWith("!") && (a = a.slice(1), u = "!"), !a.startsWith("./") && !a.startsWith("../")) return;
        let s = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].posix.join((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizePath"])(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(l)), a), f = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].posix.dirname((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizePath"])(o)), c = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].posix.relative(f, s);
        c.startsWith(".") || (c = "./" + c), t.params = i + u + c + i, e.add(t);
    }
    return {
        postcssPlugin: "tailwindcss-postcss-fix-relative-paths",
        Once (t) {
            t.walkAtRules(/source|plugin|config/, r);
        }
    };
}
var p = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["env"].DEBUG, ce = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$alloc$2f$quick$2d$lru$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"]({
    maxSize: 50
});
function Gt(e, r, t) {
    let o = `${r}:${t.base ?? ""}:${JSON.stringify(t.optimize)}`;
    if (ce.has(o)) return ce.get(o);
    let l = {
        mtimes: new Map,
        compiler: null,
        scanner: null,
        tailwindCssAst: [],
        cachedPostCssAst: e.root(),
        optimizedPostCssAst: e.root(),
        fullRebuildPaths: []
    };
    return ce.set(o, l), l;
}
function qt(e = {}) {
    let r = e.base ?? process.cwd(), t = e.optimize ?? process.env.NODE_ENV === "production", o = e.transformAssetUrls ?? !0;
    return {
        postcssPlugin: "@tailwindcss/postcss",
        plugins: [
            se(),
            {
                postcssPlugin: "tailwindcss",
                async Once (l, { result: n, postcss: i }) {
                    var T = [];
                    try {
                        let a = me(T, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Instrumentation"]);
                        let u = n.opts.from ?? "";
                        let s = u.endsWith(".module.css");
                        p && a.start(`[@tailwindcss/postcss] ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["relative"])(r, u)}`);
                        {
                            p && a.start("Quick bail check");
                            let y = !0;
                            if (l.walkAtRules((g)=>{
                                if (g.name === "import" || g.name === "reference" || g.name === "theme" || g.name === "variant" || g.name === "config" || g.name === "plugin" || g.name === "apply" || g.name === "tailwind") return y = !1, !1;
                            }), y) return;
                            p && a.end("Quick bail check");
                        }
                        let f = Gt(i, u, e);
                        let c = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(u));
                        let m = f.compiler === null;
                        async function O() {
                            p && a.start("Setup compiler"), f.fullRebuildPaths.length > 0 && !m && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$require$2d$cache$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["clearRequireCache"])(f.fullRebuildPaths), f.fullRebuildPaths = [], p && a.start("PostCSS AST -> Tailwind CSS AST");
                            let y = Fe(l);
                            p && a.end("PostCSS AST -> Tailwind CSS AST"), p && a.start("Create compiler");
                            let g = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["compileAst"])(y, {
                                from: n.opts.from,
                                base: c,
                                shouldRewriteUrls: o,
                                onDependency: (J)=>f.fullRebuildPaths.push(J),
                                polyfills: s ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].All ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].AtProperty : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].All
                            });
                            return p && a.end("Create compiler"), p && a.end("Setup compiler"), g;
                        }
                        try {
                            if (f.compiler ??= O(), (await f.compiler).features === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].None) return;
                            let y = "incremental";
                            p && a.start("Register full rebuild paths");
                            {
                                for (let k of f.fullRebuildPaths)n.messages.push({
                                    type: "dependency",
                                    plugin: "@tailwindcss/postcss",
                                    file: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(k),
                                    parent: n.opts.from
                                });
                                let _ = n.messages.flatMap((k)=>k.type !== "dependency" ? [] : k.file);
                                _.push(u);
                                for (let k of _){
                                    let E = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].statSync(k, {
                                        throwIfNoEntry: !1
                                    })?.mtimeMs ?? null;
                                    if (E === null) {
                                        k === u && (y = "full");
                                        continue;
                                    }
                                    f.mtimes.get(k) !== E && (y = "full", f.mtimes.set(k, E));
                                }
                            }
                            p && a.end("Register full rebuild paths"), y === "full" && !m && (f.compiler = O());
                            let g = await f.compiler;
                            if (f.scanner === null || y === "full") {
                                p && a.start("Setup scanner");
                                let _ = (g.root === "none" ? [] : g.root === null ? [
                                    {
                                        base: r,
                                        pattern: "**/*",
                                        negated: !1
                                    }
                                ] : [
                                    {
                                        ...g.root,
                                        negated: !1
                                    }
                                ]).concat(g.sources);
                                f.scanner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$oxide$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["Scanner"]({
                                    sources: _
                                }), p && a.end("Setup scanner");
                            }
                            p && a.start("Scan for candidates");
                            let J = g.features & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].Utilities ? f.scanner.scan() : [];
                            if (p && a.end("Scan for candidates"), g.features & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$MEY3PWYT$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].Utilities) {
                                p && a.start("Register dependency messages");
                                let _ = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(r, u);
                                for (let k of f.scanner.files){
                                    let E = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(k);
                                    E !== _ && n.messages.push({
                                        type: "dependency",
                                        plugin: "@tailwindcss/postcss",
                                        file: E,
                                        parent: n.opts.from
                                    });
                                }
                                for (let { base: k, pattern: E } of f.scanner.globs)E === "*" && r === k || (E === "" ? n.messages.push({
                                    type: "dependency",
                                    plugin: "@tailwindcss/postcss",
                                    file: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(k),
                                    parent: n.opts.from
                                }) : n.messages.push({
                                    type: "dir-dependency",
                                    plugin: "@tailwindcss/postcss",
                                    dir: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(k),
                                    glob: E,
                                    parent: n.opts.from
                                }));
                                p && a.end("Register dependency messages");
                            }
                            p && a.start("Build utilities");
                            let Y = g.build(J);
                            if (p && a.end("Build utilities"), f.tailwindCssAst !== Y) if (t) {
                                p && a.start("Optimization"), p && a.start("AST -> CSS");
                                let _ = K(Y);
                                p && a.end("AST -> CSS"), p && a.start("Lightning CSS");
                                let k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["optimize"])(_, {
                                    minify: typeof t == "object" ? t.minify : !0
                                });
                                p && a.end("Lightning CSS"), p && a.start("CSS -> PostCSS AST"), f.optimizedPostCssAst = i.parse(k.code, n.opts), p && a.end("CSS -> PostCSS AST"), p && a.end("Optimization");
                            } else p && a.start("Transform Tailwind CSS AST into PostCSS AST"), f.cachedPostCssAst = Me(i, Y, l.source), p && a.end("Transform Tailwind CSS AST into PostCSS AST");
                            f.tailwindCssAst = Y, p && a.start("Update PostCSS AST"), l.removeAll(), l.append(t ? f.optimizedPostCssAst.clone().nodes : f.cachedPostCssAst.clone().nodes), l.raws.indent = "  ", p && a.end("Update PostCSS AST"), p && a.end(`[@tailwindcss/postcss] ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["relative"])(r, u)}`);
                        } catch (y) {
                            f.compiler = null;
                            for (let g of f.fullRebuildPaths)n.messages.push({
                                type: "dependency",
                                plugin: "@tailwindcss/postcss",
                                file: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(g),
                                parent: n.opts.from
                            });
                            throw console.error(y), y && typeof y == "object" && "message" in y ? l.error(`${y.message}`) : l.error(`${y}`);
                        }
                    } catch (Be) {
                        var Ye = Be, Ge = !0;
                    } finally{
                        ge(T, Ye, Ge);
                    }
                }
            }
        ]
    };
}
var Zl = Object.assign(qt, {
    postcss: !0
});
;
}),
];

//# sourceMappingURL=node_modules_efd5f211._.js.map